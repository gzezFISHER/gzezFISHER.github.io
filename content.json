{"pages":[{"title":"404 not found","text":"404","link":"/404.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"我的洛谷账号: FISHER_ Github: gzezFISHER","link":"/about/index.html"}],"posts":[{"title":"CF1118F2 Tree Cutting (Hard Version)","text":"题意给定一个有 $n$ 个节点的树，节点可能有颜色，共 $k$ 种颜色，编号 $1…k$，保证每种颜色都出现. 有的点没有颜色，用 $0$ 表示. 将其划分为 $k$ 个联通块，是每个联通块中有且仅有一种颜色，颜色为 $0$ 的节点可以在任意联通块中. 求有多少中划分的方案. $2\\le k\\le n\\le 3\\times 10^5$，答案对 $998244353$ 取模. 题解将归类视为染色 显然有一些点的染色是确定的，一些点可以染上多种颜色，其中所有颜色为 $c$ 的点与它们的LCA的路径上的点确定染上颜色 $c$ 先将这些颜色确定的点染色： 找出同一颜色 $c$ 的点的LCA 依次从每个点开始往父亲上跳，一边跳一边染色 跳到一个点已经染色或已经到达LCA即可停止，如果跳到的点已经染上颜色且不为 $c$ 则两种颜色构成的联通块必然重叠，即没有合法方案 接下来考虑树形DP令 $f_{u,0}$ 表示在以 $u$ 为根的子树中，最上方联通块不包含已染色点的方案数，$f_{u,1}$ 表示在以 $u$ 为根的子树中，最上方联通块包含已染色点的方案数，$c_u$ 表示点 $u$ 的颜色 分两种情况讨论转移： $c_u\\not=0$ 显然 $f_{u, 0}=0$ 对于 $f_{u, 1}$，再分情况讨论： $v\\in\\text{son}_u,c_v\\not=0$ 能够确定边 $(u, v)$ 是否删去，对 $f_{u, 1}$ 贡献为 $f_{v, 1}=f_{v, 0}+f_{v, 1}$ $v\\in\\text{son}_u,c_v=0$ 若边 $(u, v)$ 删去，$v$ 所在联通块必须有色，对 $f_{u, 1}$ 贡献为 $f_{v, 1}$ 若边 $(u, v)$ 保留，$v$ 所在联通块必须无色，对 $f_{u, 1}$ 贡献为 $f_{v, 0}$ 总贡献为 $f_{v, 0}+f_{v, 1}$ 综上，$f_{u, 1}=\\prod\\limits_{v\\in\\text{son}_u}f_{v, 0}+f_{v, 1}$ $c_u=0$ 类似的，$f_{u, 0}=\\prod\\limits_{v\\in\\text{son}_u}f_{v, 0}+f_{v, 1}$ 对于 $f_{u, 1}$，枚举 $u$ 继承哪一个儿子节点的颜色，即 $f_{u, 1}=\\sum\\limits_{v_1\\in\\text{son}_u}f_{v_1, 1}\\times\\prod\\limits_{v_2\\in\\text{son}_u,v_2\\not=v_1}f_{v_2, 0}+f_{v_2, 1}$ 对这条式子维护 $f_{v, 0}+f_{v, 1}$ 的前缀积和后缀积即可 总的时间复杂度 $\\Theta(n)$ 到 $\\Theta(n\\log n)$，取决于求LCA的算法 代码 codeforces submission 143330738","link":"/2022/01/27/cf1118f2/"},{"title":"CF1039D You Are Given a Tree","text":"题意给定一棵有 $n$ 个节点的树. 对于满足 $1\\le k\\le n$ 的每一个 $k$，把树分成若干条包含 $k$ 个顶点的链，其中每个点最多属于一条链，问最多能分得几条链. $n\\le 10^5$ 题解考虑 $k$ 固定时怎么做 我们自下而上贪心，对于一个点，如果在它的子树内有一条经过该点且不经过以被使用点的链，那么我们就将这条链计入答案并将该点标记为使用过 简单的证明：对于点 $u$ 满足在其子树内有一条经过该点且不经过以被使用点的链，如果这条链不计入答案，而是选取一条经过 $u$ 的但不完全在 $u$ 子树中的链，这样划分的链数不会增加，反而会占用这条链在点 $u$ 子树外的点因此，按照上述方法贪心是最优的 令 $f_i$ 表示 $k=i$ 时的答案，显然有 $f_i\\le\\lfloor\\frac{n}{i}\\rfloor$ 类似除法分块，$f_i$ 一共只有 $\\mathcal{O}(\\sqrt{n})$ 种取值 因此对于每一种取值二分右端点，时间复杂度为 $\\mathcal{O}(n\\sqrt{n}\\log n)$，不足以通过此题 考虑对前 $T$ 项直接暴力，只对后面的 $\\mathcal{O}(\\frac{n}{T})$ 种取值二分 时间复杂度为 $\\mathcal{O}(nT+\\frac{n}{T}\\log n)$，$T$ 取 $\\sqrt{n\\log n}$ 时有最优复杂度 $\\mathcal{O}(n\\sqrt{n\\log n})$ 代码 codeforces submission 144337474","link":"/2022/01/29/cf1039d/"},{"title":"CF1436F Sum Over Subsets","text":"题意给出一个可重集 $S$，值为 $i$ 的元素有 $freq_i$ 个有两个集合 $A,B$ 满足 $B\\subset A\\subseteq S$ $|B|=|A|-1$ $\\gcd\\limits_{x\\in A}x=1$ 称这两个集合的权值 $w(A,B)=\\sum\\limits_{x\\in A}x\\sum\\limits_{y\\in B}y$求所有可能的集合对 $(A, B)$ 的权值之和 $1\\le a_i\\le10^5,freq_i\\le10^9$ 题解$\\gcd_{x\\in A}x=1$ 是一个棘手的条件 考虑令 $f_i$ 表示满足 $\\gcd\\limits_{x\\in A}x=i$ 时的答案，$g_i$ 表示满足 $i\\mid\\gcd_{x\\in A}x$ 时的答案有 $g_i=\\sum\\limits_{i\\mid j}f_j$求出 $g$ 以后，可以莫比乌斯反演得到 $f$即 $f_i=\\sum\\limits_{j\\mid i}\\mu(j)\\times g_j$ 所以答案 $\\text{Ans}=\\sum\\limits_{1\\le i}\\mu(i)\\times g_i$ 接下来考虑求 $g_i$ 先构造集合 $S’=\\{x|x\\in S,i\\mid x\\}$有 \\begin{align*} g_i&=\\sum_{B\\subset A\\subseteq S',|B|=|A|-1}w(A,B)\\\\ &=\\sum_{B\\subset A\\subseteq S',|B|=|A|-1}\\sum_{x\\in A}\\sum_{y\\in B}x\\times y \\end{align*}考虑每一对 $(x\\in A, y\\in B)$ 对 $g_i$ 的贡献 称在集合 $A$ 中但不再集合 $B$ 中的元素为特殊元素，在集合 $A$ 和 $B$ 中的为普通元素分两种情况讨论： $x, y$ 是同一个元素显然 $x$ 是普通元素那么我们从剩下 $|S’|-1$ 个元素中选出一个特殊元素，再从剩下的 $|S’|-2$ 个元素中任选若干个作为普通元素有 $(|S’|-1)\\times 2^{|S’|-2}$ 种方案，产生 $(|S’|-1)\\times 2^{|S’|-2}\\times x^2$ 的贡献 $x, y$ 是不同的元素，注意是元素不同，不是值不同显然 $y$ 是普通元素若 $x$ 是普通元素，类似的有 $(|S’|-2)\\times 2^{|S’|-3}$ 种方案若 $x$ 是特殊元素，在剩下的 $|S’|-2$ 个元素中任选作为普通元素，有 $s^{|S’|-2}$ 种方案共 $(|S’|-2)\\times 2^{|S’|-3}+s^{|S’-2|}$ 种方案，产生贡献 $[(|S’|-2)\\times 2^{|S’|-3}+s^{|S’|-2}]\\times x\\times y$ 回到本题，由于 $freq$ 特别大，我们把值相同的元素放在一起考虑相同值 $x$ 之间的贡献有两种 同元素套用上面同元素的贡献，乘上值为 $x$ 的元素个数即可即有贡献 $(|S’|-1)\\times 2^{|S’|-2}\\times x^2\\times freq_x$ 不同元素套用上面不同元素的贡献即有贡献 $[(|S’|-2)\\times 2^{|S’|-3}+s^{|S’|-2}]\\times x^2\\times freq_x\\times (freq_x-1)$ 不同的值 $x, y$ 之间的贡献类似的 $[(|S’|-2)\\times 2^{|S’|-3}+s^{|S’|-2}]\\times x\\times y\\times freq_x\\times freq_y$ 直接求 $\\sum\\limits_{x,y\\in S’,x\\not =y}[(|S’|-2)\\times 2^{|S’|-3}+s^{|S’|-2}]\\times x\\times y\\times freq_x\\times freq_y$ 显然时间上不能接受 随便优化一下就变成了 $[(|S’|-2)\\times 2^{|S’|-3}+s^{|S’|-2}][(\\sum_{x\\in S’}x\\times freq_x)^2-\\sum_{x\\in S’}(x\\times freq_x)^2]$ 复杂度为调和级数，即 $\\Theta(n\\log n)$ 代码 codeforces submission 144913462","link":"/2022/02/02/cf1436f/"},{"title":"CF1588F Jumping Through the Array","text":"题意有一个长度为 $n$ 的数组 $a$ 和一个长度为 $n$ 的排列 $p$，对于每一个 $i$ 有一条有向边 $(i, p_i)$.有 $q$ 次如下三种操作： 1 l r，询问 $\\sum\\limits_{l\\le i\\le r}a_i$ 2 v x，将所有从 $v$ 出发能到达的节点的编号在 $a$ 上对应的值加上 $x$ 3 x y，交换 $p_x$ 和 $p_y$ $n,q\\le2\\times 10^5$ 题解考虑分块 显然对序列分块是没有用的，考虑对操作序列分块，分别计算块内和块外贡献，每块结束后暴力重构的做法 由于 $p$ 始终是一个排列，在任一时刻所有边构成的图由若干个环组成 注意到每次操作3会更改两个点的出边，称这样的点为关键点在同一个操作序列的块中的所有关键点将图分为若干色块，每个色块在这个操作序列的块中都不会发生改变 由于关键点只有 $\\mathcal{O}(\\sqrt{n})$ 个，色块也只有 $\\mathcal{O}(\\sqrt{n})$ 个 对于操作2从 $v$ 开始遍历色块，在所有能到达的色块上打一个加法标记为了实现方便，将所有 $v$ 也设为关键点 考虑操作1对于每一个询问我们将其差分为两个前缀和，也就是一个块内一共询问 $\\mathcal{O}(\\sqrt{n})$ 个前缀和由于一共只有 $\\mathcal{O}(\\sqrt{n})$ 种颜色和 $\\mathcal{O}(\\sqrt{n})$ 个有用的前缀和，可以 $\\Theta(n)$ 预处理出在所有有意义的前缀和中每种颜色的点的个数 重构的时候，每个数加上它所在色块的加法标记 每块预处理的时间复杂度为 $\\Theta(n\\sqrt{n})$，所有修改与询问的时间复杂度为 $\\mathcal{O}(n\\sqrt{n})$，因此总时间复杂度为 $\\Theta(n\\sqrt{n})$ 代码 codeforces submission 144997997","link":"/2022/02/03/cf1588f/"},{"title":"CF717A Festival Organization","text":"题意一个合法的串定义为：长度在 $[l, r]$ 之间，且只含 $0,1$，并且不存在连续 $2$ 个或更多的 $0$.现在要选出 $k$ 个长度相同的不同的合法的串，问有几种选法，答案模 $10^9+7$. $1\\le l\\le r\\le10^{18}, 1\\le k\\le200$. 题解设 $F_{i,j}$ 表示长度为 $i$, 以 $j$ 结尾的合法串个数.有 \\left\\{ \\begin{array}{**lr**} F_{i,0}=F_{i-1,1} & \\\\ F_{i,1}=F_{i-1,0}+F_{i-1,1} & \\end{array} \\right.即 \\left\\{ \\begin{array}{**lr**} F_{i,0}=\\text{Fib}_{i} & \\\\ F_{i,1}=\\text{Fib}_{i+1} & \\end{array} \\right.所以答案 \\text{Ans}=\\sum\\limits_{l+2\\le i\\le r+2}\\begin{pmatrix}\\text{Fib}_i\\\\k\\end{pmatrix} \\begin{align*} \\text{Ans} =&\\sum_{l+2\\leq i\\leq r+2} \\begin{pmatrix}{\\text{Fib}_i}\\\\k\\end{pmatrix}\\\\ =&\\frac{1}{k!}\\sum_{l+2\\le i\\le r+2} {\\text{Fib}_i}^{\\underline{k}}\\\\ =&\\frac{1}{k!}\\sum_{l+2\\le i\\le r+2}\\sum_{1\\le j\\le k}(-1)^{k-j}\\begin{bmatrix}k\\\\ j \\end{bmatrix}{\\text{Fib}_i}^j\\\\ =&\\frac{1}{k!}\\sum_{1\\le i\\le k}(-1)^{k-i}\\begin{bmatrix}k\\\\ i \\end{bmatrix}\\sum_{l+2\\le j\\le r+2}{\\text{Fib}_j}^i \\end{align*}考虑带入斐波那契数的通项，令 $A=\\frac{1+\\sqrt{5}}{2}, B=\\frac{1-\\sqrt{5}}{2}$ \\begin{align*} \\text{Ans} =&\\frac{1}{k!}\\sum_{1\\le i\\le k}(-1)^{k-i}\\begin{bmatrix}k\\\\ i \\end{bmatrix}\\sum_{l+2\\le j\\le r+2}[{\\frac{1}{\\sqrt{5}}(A^j-B^j)}]^i\\\\ =&\\frac{1}{k!}\\sum_{1\\le i\\le k}(-1)^{k-i}\\begin{bmatrix}k\\\\ i \\end{bmatrix}(\\frac{1}{\\sqrt{5}})^i\\sum_{l+2\\le j\\le r+2}\\sum_{0\\le p\\le i}\\begin{pmatrix}i\\\\p\\end{pmatrix}(-1)^p(A^{i-p}B^p)^j\\\\ =&\\frac{1}{k!}\\sum_{1\\le i\\le k}(-1)^{k-i}\\begin{bmatrix}k\\\\ i \\end{bmatrix}(\\frac{1}{\\sqrt{5}})^i\\sum_{0\\le j\\le i}\\begin{pmatrix}i\\\\j\\end{pmatrix}(-1)^j\\sum_{l+2\\le p\\le r+2}(A^{i-j}B^j)^p \\end{align*}等比数列求和快速计算式子后面部分$\\Theta(k^2\\times(\\log l+\\log r))$ 代码 codeforces submission 137205589","link":"/2022/01/26/cf717a/"},{"title":"CF802O April Fools&#39; Problem (hard)","text":"题意有 $n$ 道题，第 $i$ 天可以花费 $a_i$ 准备一道题，花费 $b_i$ 打印一道题，每天最多准备一道题，打印一道题，准备的题可以留到以后打印，求打印 $k$ 道题的最小花费. $1\\le k\\le n\\le 5\\times10^5$ 题解显然可以费用流解决，建图如下. 考虑优化费用流 引理 初始不含负圈的图在费用流的增广过程中不会出现负圈 根据引理得，每次增广的增广路都是一条形如 $S\\rightarrow X\\rightarrow Y\\rightarrow T’\\rightarrow T$ 的路径，一共增广 $k$ 次. 设 $f_i$ 表示在残流网络上 $i+1$ 点向 $i$ 的流量，则一条增广路合法当且仅当 $S\\rightarrow X,Y\\rightarrow T’$ 这两条边有流量且满足下列两个条件之一： $X\\le Y$ $X&gt;Y\\land \\min_{Y\\le i&lt;X}f_i&gt;0$ 尝试用线段树来模拟这一过程，对于每一个区间 $[l, r]$，维护 $a$ 的最小值 $\\text{minA}$，$b$ 的最小值 $\\text{minB}$，从 $x$ 到 $l$ 有流量的最小 $a_x$ $\\text{flowA}$，从 $r+1$ 到 $x$ 有流量的最小 $b_x$ $\\text{flowB}$，从左到右的最小费用流 $\\text{flowLtoR}$，从右到左的最小费用流 $\\text{flowRtoL}$，从 $r+1$ 到 $l$ 的流量 $\\text{minFlow}$ 每找到一条增广路，在线段树上更新流量并把 $a_X,b_Y$ 设为 $\\text{Infinity}$ 这时候发现这个做法是不可行的，因为没法对流量快速地区间修改 发现 $f_n$ 的值总是 $0$，于是使 $\\text{flowA}$，$\\text{flowB}$ 和 $\\text{flowRtoL}$ 取整个区间每条边的流量都减去 $\\text{minFlow}$之后的值，这样不影响区间 $[1, n]$ 的答案，而且区间修改时只需要更新 $\\text{minFlow}$ 为了方便pushup，还需要 $\\text{minFlowRtoL}$ 表示假设区间内从右到左的每条边都有流量时，从右到左最小的费用 细节详见代码 每次增广的时间复杂度可以做到 $\\Theta(\\log n)$，总时间复杂度为 $\\Theta(k\\log n)$ 代码 codeforces submission 143973639","link":"/2022/01/26/cf802o/"},{"title":"CF997D Cycles in product","text":"题意给你大小为 $n_1, n_2$​的两棵树 $T_1, T_2$​，构造一张新图，该图中每一个点的编号为 $(u,v)$。如果在 $T_1$ ​中， $u_1$ ​和$u_2$ ​之间有边，那么在该图上，对于任意 $1\\le v\\le n_2$，$(u_1, v)$ 和 $(u_2, v)$ 之间有边。同样，如果在 $T_2$ ​中，$v_1$ ​和$v_2$​之间有边，那么在图上，对于任意 $1\\le u\\le n_1$，$(u, v_1)$ 和 $(u, v_2)$ 之间有边.求这个图上长度为 $K$ 的环有多少个，环可以不为简单环，起始点或方向不同的环视为不同的环. $n_1, n_2\\le 4000, K\\le 75$，答案对 $998244353$ 取模. 题解$T_1$ 上一个长度为 $K_1$ 的环和 $T_2$ 上一个长度为 $K_2$ 的环以不同方式组合对应图上 $\\begin{pmatrix}K_1+K_2\\\\k_1\\end{pmatrix}$ 个环即答案为 $\\sum\\limits_{0\\le i\\le K}F1_i\\times F2_{K-i}\\times\\begin{pmatrix}K\\\\i\\end{pmatrix}$，其中 $F1_i$ 表示 $T_1$ 上长度为 $i$ 的环的个数，$F2_i$ 表示 $T_2$ 上长度为 $i$ 的环的个数 我们把每个点作为起始点分别计算，考虑到树上所有的环长度均为偶数，令 $f_{u, k}$ 表示以 $u$ 为起始点，长度为 $2\\times k$ 的环的个数，有 $F_{2\\times k}=\\sum\\limits_u f_{u, k}$由于从父亲节点往儿子节点转移十分困难，不妨对于每个点只考虑在其子树中的环然后换根DP考虑转移 f_{u,k}=\\sum_{0\\le t","link":"/2022/01/26/cf997d/"},{"title":"LOJ6241 性能优化","text":"题意求 T = \\sum_{1\\le i\\le n}\\sum_{1\\le j\\le\\lfloor \\frac{n}{i} \\rfloor}\\sum_{1\\le k\\le j}[\\gcd(j,k)=1]多组数据$n\\le 10^{10^6}$ 题解T = \\sum_{1\\le i\\le n}\\sum_{1\\le j\\le\\lfloor \\frac{n}{i} \\rfloor}\\varphi(j)令 \\text{S}(n) = \\sum_{1\\le i\\le n}\\varphi(i)则有 \\begin{align*} T &= \\sum_{1\\le i\\le n}\\text{S}(\\lfloor \\frac{n}{i} \\rfloor) \\\\ &= \\text{S}(n) + \\sum_{2\\le i\\le n}\\text{S}(\\lfloor \\frac{n}{i} \\rfloor) \\\\ \\end{align*}根据杜教筛，由 $\\varphi*\\text{I}=\\text{Id}$，有 \\text{I}(1)\\times \\text{S}(n)=\\sum_{1\\le i\\le n}\\text{Id}(i)-\\sum_{2\\le i\\le n}\\text{S}(\\lfloor\\frac{n}{i}\\rfloor)\\times \\text{I}(i)即 \\text{S}(n)=\\frac{n(n+1)}{2}-\\sum_{2\\le i\\le n}\\text{S}(\\lfloor\\frac{n}{i}\\rfloor)带回原式得 \\begin{align*} T=&\\frac{n(n+1)}{2}-\\sum_{2\\le i\\le n}\\text{S}(\\lfloor\\frac{n}{i}\\rfloor) + \\sum_{2\\le i\\le n}\\text{S}(\\lfloor \\frac{n}{i} \\rfloor)\\\\ =&\\frac{n(n+1)}{2} \\end{align*}","link":"/2021/01/15/loj6241/"},{"title":"LUOGU P4119 Ynoi2018 未来日记","text":"题意有一个长度为 $n$ 的序列，共 $m$ 次操作： 1 l r x y，把区间 $[l, r]$ 内所有 $x$ 变成 $y$； 2 l r k，查询区间 $[l, r]$ 内第 $k$ 小值. $1\\le n, m\\le 10^5$，任何时刻 $1\\le a_i\\le 10^5$ 题解考虑分块 对序列和值域同时分块，维护 $sum_{i, v}$ 表示前 $i$ 块内值 $v$ 的个数，$blsum_{i, j}$ 表示序列前 $i$ 块内值在值域第 $j$ 块内的个数 考虑查询，对于散块每次查询构造 $sctsum_{v}$ 表示在散块中值为 $v$ 的个数，$sctblsum_{i}$ 表示散块中值在值域第 $i$ 块内的个数 查询时对整块差分再加上散块的贡献，即可 $\\Theta(1)$ 地查询区间 $[l, r]$ 内值为 $v$ 的个数和区间内值在值域第 $i$ 块中的个数 先枚举 $k$ 小值在值域中的哪一块，再枚举 $k$ 小值是该块中的哪一个值，一次查询的时间复杂度为 $\\Theta(\\sqrt{n})$ 考虑修改，对于散块直接暴力修改 对于每个整块维护一个类似并查集的东西给块内每一个值一个标号 $id$，颜色相同的有相同的标号，还需要维护值对标号的映射 $rep$ 和值对标号的映射 $col$ 把 $x$ 变成 $y$ 时的两种情况： 块内没有 $y$将 $col_{rep_x}$ 设为 $y$，将 $rep_y$ 设为原来的 $rep_x$，将 $rep_x$ 清空 块内有 $y$接像对散块一样暴力修改考虑这样做的时间复杂度暴力修改的次数不多于所有块内不同值个数的和，一开始有 $\\mathcal{O}(n)$ 个，每修改一次整块不会增加，只有散块可能增加1，所以总共暴力修改 $\\mathcal{O}(n+m)$ 次，总的暴力修改复杂度即为 $\\mathcal{O}((n+m)\\sqrt{n})$ “reset” 的时候，对于每个值用标号映射得到新的值，也就是将每个 $a_i$ 设为 $col_{id_i}$ 总的时间复杂度为 $\\mathcal{O}((n+m)\\sqrt{n})$ 代码P4119.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000, maxvs = 316;const int maxs = 360, maxc = 278;int cnt;int a[maxn + 5];int lp[maxc + 5], rp[maxvs + 5];int bl[maxn + 5];int vlp[maxvs + 5];int vbl[maxn + 5];int sum[maxc + 5][maxn + 5];int blsum[maxc + 5][maxvs + 5];int rep[maxc + 5][maxn + 5];int col[maxc + 5][maxs + 5];int id[maxn + 5];int ccnt[maxc + 5];void buildUnion(int bid) { for (int i = 1; i &lt;= ccnt[bid]; i++) rep[bid][col[bid][i]] = 0; ccnt[bid] = 0; for (int i = lp[bid]; i &lt;= rp[bid]; i++) { if (rep[bid][a[i]] == 0) { rep[bid][a[i]] = ++ccnt[bid]; col[bid][ccnt[bid]] = a[i]; } id[i] = rep[bid][a[i]]; }}void reset(int bid) { for (int i = lp[bid]; i &lt;= rp[bid]; i++) a[i] = col[bid][id[i]];}void build(int n) { int siz = min(n, int(sqrt(1.3 * n))); cnt = ceil(1. * n / siz); for (int i = 1; i &lt;= n; i++) bl[i] = (i - 1) / siz + 1; for (int i = 1; i &lt;= cnt; i++) { lp[i] = (i - 1) * siz + 1; rp[i] = min(n, i * siz); } for (int i = 1; i &lt;= maxn; i++) vbl[i] = (i - 1) / maxvs + 1; for (int i = 1; i &lt;= maxvs + 1; i++) vlp[i] = (i - 1) * maxvs + 1; for (int i = 1; i &lt;= cnt; i++) { for (int j = 1; j &lt;= maxn; j++) sum[i][j] = sum[i - 1][j]; for (int j = 1; j &lt;= maxvs + 1; j++) blsum[i][j] = blsum[i - 1][j]; for (int j = lp[i]; j &lt;= rp[i]; j++) { sum[i][a[j]]++; blsum[i][vbl[a[j]]]++; } buildUnion(i); }}int tmp[maxn + 5], bltmp[maxvs + 5];void add(int l, int r, int delta) { for (int i = l; i &lt;= r; i++) { tmp[a[i]] += delta; bltmp[vbl[a[i]]] += delta; }}int query(int l, int r, int k) { int lb = bl[l], rb = bl[r]; int res; if (lb == rb) { reset(lb); copy(a + l, a + r + 1, tmp + l); nth_element(tmp + l, tmp + l + k - 1, tmp + r + 1); res = tmp[l + k - 1]; fill(tmp + l, tmp + r + 1, 0); } else { reset(lb); reset(rb); add(l, rp[lb], 1); add(lp[rb], r, 1); int i = 1, delta; for (; k - (delta = bltmp[i] + blsum[rb - 1][i] - blsum[lb][i]) &gt; 0; i++) k -= delta; int j = vlp[i]; for (; k - (delta = tmp[j] + sum[rb - 1][j] - sum[lb][j]) &gt; 0; j++) k -= delta; res = j; add(l, rp[lb], -1); add(lp[rb], r, -1); } return res;}void change(int l, int r, int x, int y, int bid) { int chcnt = 0; for (int i = l; i &lt;= r; i++) { if (a[i] == x) { a[i] = y; chcnt++; } } sum[bid][x] -= chcnt; sum[bid][y] += chcnt; blsum[bid][vbl[x]] -= chcnt; blsum[bid][vbl[y]] += chcnt;}void changeBlock(int l, int r, int x, int y, int bid) { reset(bid); change(l, r, x, y, bid); buildUnion(bid);}void modify(int l, int r, int x, int y) { int lb = bl[l], rb = bl[r]; if (x == y || sum[rb][x] - sum[lb - 1][x] == 0) return; for (int i = cnt; i &gt;= lb; i--) { sum[i][x] -= sum[i - 1][x]; sum[i][y] -= sum[i - 1][y]; blsum[i][vbl[x]] -= blsum[i - 1][vbl[x]]; blsum[i][vbl[y]] -= blsum[i - 1][vbl[y]]; } if (lb == rb) changeBlock(l, r, x, y, lb); else { changeBlock(l, rp[lb], x, y, lb); changeBlock(lp[rb], r, x, y, rb); for (int i = lb + 1; i &lt; rb; i++) { if (sum[i][x] == 0) continue; if (sum[i][y] == 0) { col[i][rep[i][x]] = y; swap(rep[i][y], rep[i][x]); blsum[i][vbl[y]] += sum[i][x]; blsum[i][vbl[x]] -= sum[i][x]; sum[i][y] = sum[i][x]; sum[i][x] = 0; } else changeBlock(lp[i], rp[i], x, y, i); } } for (int i = lb; i &lt;= cnt; i++) { sum[i][x] += sum[i - 1][x]; sum[i][y] += sum[i - 1][y]; blsum[i][vbl[x]] += blsum[i - 1][vbl[x]]; blsum[i][vbl[y]] += blsum[i - 1][vbl[y]]; }}int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); build(n); for (int i = 1; i &lt;= m; i++) { int op, l, r; scanf(&quot;%d%d%d&quot;, &amp;op, &amp;l, &amp;r); if (op == 1) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); modify(l, r, x, y); } else { int k; scanf(&quot;%d&quot;, &amp;k); printf(&quot;%d\\n&quot;, query(l, r, k)); } }}","link":"/2022/02/01/luogu4119/"},{"title":"UOJ435 Simple Tree","text":"题意有一棵有根树，根为 $1$，点有点权.现在有 $m$ 次操作，操作有3种： 1 x y w，将 $x$ 到 $y$ 的路径上的点点权加上 $w$ (其中 $w=\\pm 1$)； 2 x y，询问在 $x$ 到 $y$ 的路径上有多少个点点权 $&gt;0$； 3 x，询问在 $x$ 的子树里的点有多少个点点权 $&gt;0$. 强制在线，$n,m\\le 10^5,-10^9\\le\\text{点权}\\le10^9$ 题解先考虑序列上的做法问题比较复杂，我们用分块来处理 我们把每一块内部预先排好序，维护在排好序的块内下标最小的大于零点的下标 $pts$ 以及对于块中每个数第一个严格大于和小于该数的位置 $nxt$ 和 $lst$ 查询的时候，对于整块，用右端点减去 $pts$ 即可得到答案对于散块暴力统计 修改的时候，对于整块，我们修改零点，然后尝试让 $pts$ 往 $nxt$ 或 $lst$ 跳对于散块，暴力修改并归并排序 把序列问题放在树上，一个显然的想法是树链剖分，$\\mathcal{O}(n\\log n+q\\sqrt{n}\\log{n})$，不足以通过此题 其实在树链剖分的情况下 $\\sqrt{n}$ 的块长不是最优的每次链的询问和修改，涉及的整块是 $\\mathcal{O}(\\sqrt{n})$ 级别的，然而涉及的散块元素个数是 $\\mathcal{O}(\\sqrt{n}\\log{n})$ 级别的，因此块长 $\\sqrt{n\\log n}$ 时取到最优复杂度 $\\mathcal{O}(n\\log n+q\\sqrt{n\\log n})$ 考虑对每条链单独分块下面证明链操作的时间复杂度是 $\\mathcal{O}(\\sqrt{n})$ 不妨考虑一条竖直的链设这条链从上到下依次经过的重链分别为 $lnk_0, lnk_1, …, lnk_k$由树链剖分的性质，有 \\text{len}(lnk_i)\\le\\text{subtreeSize}(\\text{top}(lnk_i))\\le\\frac{n}{2^i}\\begin{align*} T(n)&=\\sum_{0\\le i\\le k}\\sqrt{\\text{len}(lnk_i)}\\\\ &\\le\\sum_{0\\le i\\le k}\\sqrt{\\frac{n}{2^i}}\\\\ &=\\sqrt{n}\\sum_{0\\le i\\le k}\\frac{1}{\\sqrt{2}}^i\\\\ &=\\Theta(\\sqrt{n}) \\end{align*}即复杂度为 $\\mathcal{O}(\\sqrt{n})$ 下面考虑子树查询 我们把每条重链按链顶dfn序排序，发现每棵子树都是由一条重链的一部分和排序后连续的完整重链构成修改时，对于 $\\mathcal{O}(\\log n)$ 条被修改的重链，在树状数组上更新答案子树询问时，区间查询即可 总复杂度为 $\\mathcal{O}(n\\log n+q\\sqrt{n}+q\\log^2 n)$ 代码uoj435.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000, maxs = 200;int n, q, T;int val[maxn + 5];vector&lt;int&gt; g[maxn + 5];int stamp;int dep[maxn + 5];int fa[maxn + 5];int heavy_son[maxn + 5];int siz[maxn + 5];int tp[maxn + 5], bt[maxn + 5];int id[maxn + 5];int lnk[maxn + 5];int lcnt;int lid[maxn + 5];int minl[maxn + 5], maxl[maxn + 5];void dfs1(int u, int f) { fa[u] = f; dep[u] = dep[f] + 1; siz[u] = 1; for (size_t i = 0; i &lt; g[u].size(); i++) { int v = g[u][i]; if (v == f) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[heavy_son[u]]) heavy_son[u] = v; }}void dfs2(int u, int f, int top) { id[u] = ++stamp; lnk[u] = top; if (u == top) tp[++lcnt] = id[u]; if (heavy_son[u] == 0) bt[lcnt] = id[u]; lid[u] = lcnt; minl[u] = lcnt + 1; if (heavy_son[u]) dfs2(heavy_son[u], u, top); for (size_t i = 0; i &lt; g[u].size(); i++) { int v = g[u][i]; if (v == f || v == heavy_son[u]) continue; dfs2(v, u, v); } maxl[u] = lcnt;}inline int lowbit(int x) { return x &amp; (-x);}struct fenwic { int t[maxn + 5]; void modify(int x, int y) { while (x &lt;= lcnt) { t[x] += y; x += lowbit(x); } } int query_(int x) const { int res = 0; while (x &gt; 0) { res += t[x]; x -= lowbit(x); } return res; } int query(int l, int r) const { return query_(r) - query_(l - 1); }} bit;struct block { int cnt; int tot[maxn + 5]; int a[maxn + 5]; int blg[maxn + 5]; int zero[maxn + 5]; int lp[maxn + 5], rp[maxn + 5], pts[maxn + 5]; pair&lt;int, int&gt; tmp1[maxs + 5], tmp2[maxs + 5]; pair&lt;int, int&gt; sorted[maxn + 5]; int nxt[maxn + 5], lst[maxn + 5], lpts[maxn + 5]; void resize(int arr[], int l, int r, int lk) { int len = r - l + 1; int bsiz = ceil(sqrt(.12 * len)); int bcnt = ceil(1. * len / bsiz); for (int i = l; i &lt;= r; i++) { a[i] = arr[i]; sorted[i] = pair&lt;int, int&gt;(arr[i], i); } for (int i = cnt + 1; i &lt;= cnt + bcnt; i++) { lp[i] = l + (i - cnt - 1) * bsiz; rp[i] = min(r, l + (i - cnt) * bsiz - 1); for (int j = lp[i]; j &lt;= rp[i]; j++) blg[j] = i; sort(sorted + lp[i], sorted + rp[i] + 1); calcNxtLst(i); tot[lk] += rp[i] - pts[i] + 1; } cnt += bcnt; } void calcNxtLst(int bid) { for (int i = rp[bid], j = rp[bid] + 1; i &gt;= lp[bid]; i--) { while (i &gt; lp[bid] &amp;&amp; sorted[i].first == sorted[i - 1].first) i--; nxt[i] = j; if (j &lt;= rp[bid]) lst[j] = i; else lpts[bid] = i; j = i; } lst[lp[bid]] = lp[bid]; pts[bid] = rp[bid] + 1; for (int i = lp[bid]; i &lt;= rp[bid]; i++) { if (sorted[i].first &gt; zero[bid]) { pts[bid] = i; break; } } } void mergeSort(int bid, int l, int r, int delta, int lk) { tot[lk] += pts[bid]; for (int i = l; i &lt;= r; i++) a[i] += delta; int cnt1 = 0, cnt2 = 0; for (int i = lp[bid]; i &lt;= rp[bid]; i++) { if (sorted[i].second &gt;= l &amp;&amp; sorted[i].second &lt;= r) tmp1[++cnt1] = pair&lt;int, int&gt;(sorted[i].first + delta, sorted[i].second); else tmp2[++cnt2] = sorted[i]; } merge(tmp1 + 1, tmp1 + cnt1 + 1, tmp2 + 1, tmp2 + cnt2 + 1, sorted + lp[bid]); calcNxtLst(bid); tot[lk] -= pts[bid]; } void modify(int l, int r, int delta, int lk) { int lb = blg[l], rb = blg[r]; if (lb == rb) mergeSort(lb, l, r, delta, lk); else { mergeSort(lb, l, rp[lb], delta, lk); mergeSort(rb, lp[rb], r, delta, lk); for (int i = lb + 1; i &lt; rb; i++) { tot[lk] += pts[i]; zero[i] -= delta; if (pts[i] &gt; rp[i]) { if (sorted[lpts[i]].first &gt; zero[i]) pts[i] = lpts[i]; } else { if (delta == 1) { if (sorted[lst[pts[i]]].first &gt; zero[i]) pts[i] = lst[pts[i]]; } else if (sorted[pts[i]].first &lt;= zero[i]) pts[i] = nxt[pts[i]]; } tot[lk] -= pts[i]; } } } int query(int l, int r) const { int res = 0; int lb = blg[l], rb = blg[r]; if (lb == rb) { for (int i = l; i &lt;= r; i++) if (a[i] &gt; zero[lb]) res++; } else { for (int i = l; i &lt;= rp[lb]; i++) if (a[i] &gt; zero[lb]) res++; for (int i = lp[rb]; i &lt;= r; i++) if (a[i] &gt; zero[rb]) res++; for (int i = lb + 1; i &lt; rb; i++) res += rp[i] - pts[i] + 1; } return res; }} bl;int queryLnk(int x, int y) { int res = 0; while (lnk[x] != lnk[y]) { if (dep[lnk[x]] &lt; dep[lnk[y]]) swap(x, y); res += bl.query(tp[lid[x]], id[x]); x = fa[lnk[x]]; } if (dep[y] &lt; dep[x]) swap(x, y); res += bl.query(id[x], id[y]); return res;}int querySubtree(int x) { return bl.query(id[x], bt[lid[x]]) + bit.query(minl[x], maxl[x]);}void modifyLnk(int x, int y, int delta) { while (lnk[x] != lnk[y]) { if (dep[lnk[x]] &lt; dep[lnk[y]]) swap(x, y); int ori = bl.tot[lid[x]]; bl.modify(tp[lid[x]], id[x], delta, lid[x]); bit.modify(lid[x], bl.tot[lid[x]] - ori); x = fa[lnk[x]]; } if (dep[y] &lt; dep[x]) swap(x, y); int ori = bl.tot[lid[x]]; bl.modify(id[x], id[y], delta, lid[x]); bit.modify(lid[x], bl.tot[lid[x]] - ori);}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;q, &amp;T); for (int i = 1; i &lt; n; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } dfs1(1, 0); dfs2(1, 0, 1); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;val[id[i]]); for (int i = 1; i &lt;= lcnt; i++) { bl.resize(val, tp[i], bt[i], i); bit.modify(i, bl.tot[i]); } int lstans = 0; for (int i = 1; i &lt;= q; i++) { int op, x, y, w; scanf(&quot;%d%d&quot;, &amp;op, &amp;x); if (T == 1) x ^= lstans; if (op == 1) { scanf(&quot;%d%d&quot;, &amp;y, &amp;w); if (T == 1) y ^= lstans; modifyLnk(x, y, w); } else if (op == 2) { scanf(&quot;%d&quot;, &amp;y); if (T == 1) y ^= lstans; printf(&quot;%d\\n&quot;, lstans = queryLnk(x, y)); } else printf(&quot;%d\\n&quot;, lstans = querySubtree(x)); }}","link":"/2022/01/30/uoj435/"},{"title":"UOJ450 复读机","text":"题意$k$ 种球，每种个数必须是 $d$ 的倍数，共 $n$ 个，求排成一行的方案数. $n\\le 10^9, k\\le 5\\times10^5, d\\le 3$，答案对 $19491001$ 取模. 题解 \\begin{align*} \\text{Ans}&=n!\\sum_{i_1 \\ge 0,d\\mid i_1}\\frac{1}{i_1!}\\sum_{0\\le i_2,d\\mid i_2}\\frac{1}{i_2!}\\cdots\\sum_{0\\le i_k,d\\mid i_k}\\frac{1}{i_k!}\\\\ &=[x^n]n!(\\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!})^k\\\\ \\end{align*} \\begin{align*} \\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!}&=\\sum_{i\\ge 0}\\frac{x^i}{i!}\\frac{1}{d}\\sum_{0\\le j < d}{\\omega_d^j}^i& \\text{单位根反演}\\\\ &=\\frac{1}{d}\\sum_{0\\le j < d}\\sum_{i\\ge 0}\\frac{(x\\omega_d^j)^i}{i!}\\\\ &=\\frac{1}{d}\\sum_{0\\le j < d}e^{x\\omega_d^j}& \\text{泰勒展开}\\\\ \\end{align*}$d=2$： \\begin{align*} \\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!}&=\\frac{1}{d}\\sum_{0\\le j < d}e^{x\\omega_d^j}\\\\ &=\\frac{e^x+e^{-x}}{2}\\\\ (\\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!})^k&=n!(\\frac{e^x+e^{-x}}{2})^k\\\\ &=\\frac{1}{2^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}e^{ix}e^{-x(k-i)} & \\text{二项式定理}\\\\ &=\\frac{1}{2^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}e^{2ix-kx}\\\\ \\text{Ans}&=[x^n]n!(\\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!})^k\\\\ &=\\frac{n!}{2^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}[x^n]e^{2ix-kx}\\\\ &=\\frac{n!}{2^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\frac{(2i-k)^n}{n!} & \\text{泰勒展开}\\\\ &=\\frac{1}{2^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}(2i-k)^n \\end{align*}$d=3$： \\begin{align*} \\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!}&=\\frac{1}{d}\\sum_{0\\le j < d}e^{x\\omega_d^j}\\\\ &=\\frac{e^x+e^{\\omega_3x}+e^{\\omega_3^2x}}{3}\\\\ (\\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!})^k&=n!(\\frac{e^x+e^{\\omega_3x}+e^{\\omega_3^2x}}{3})^k\\\\ &=\\frac{1}{3^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\sum_{0\\le j\\le k-i}\\begin{pmatrix}k-i\\\\j\\end{pmatrix}e^{ix}e^{j\\omega_3x}e^{(k-i-j)\\omega_3^2x} & \\text{多项式定理}\\\\ &=\\frac{1}{3^k}\\sum_{0\\le i\\le k}\\sum_{0\\le j\\le k-i}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\begin{pmatrix}k-i\\\\j\\end{pmatrix}e^{ix+j\\omega_3x+k\\omega_3^2x-i\\omega_3^2x-j\\omega_3^2x}\\\\ \\text{Ans}&=[x^n]n!(\\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!})^k\\\\ &=\\frac{n!}{3^k}\\sum_{0\\le i\\le k}\\sum_{0\\le j\\le k-i}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\begin{pmatrix}k-i\\\\j\\end{pmatrix}[x^n]e^{ix+j\\omega_3x+k\\omega_3^2x-i\\omega_3^2x-j\\omega_3^2x}\\\\ &=\\frac{n!}{3^k}\\sum_{0\\le i\\le k}\\sum_{0\\le j\\le k-i}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\begin{pmatrix}k-i\\\\j\\end{pmatrix}\\frac{(i+j\\omega_3+k\\omega_3^2-i\\omega_3^2-j\\omega_3^2)^n}{n!} & \\text{泰勒展开}\\\\ &=\\frac{1}{3^k}\\sum_{0\\le i\\le k}\\sum_{0\\le j\\le k-i}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\begin{pmatrix}k-i\\\\j\\end{pmatrix}(i+j\\omega_3+k\\omega_3^2-i\\omega_3^2-j\\omega_3^2)^n \\end{align*}","link":"/2021/10/16/uoj450/"},{"title":"CF1610F Mashtali: a Space Oddysey","text":"题意现在有一个由 $n$ 个节点 $m$ 条边组成的无向图，每条边的边权 $w\\in\\{1, 2\\}$.令 ${d^+}_u$ 表示 $u$ 所有出边的权值和，令 ${d^-}_u$ 表示 $u$ 所有入边的权值和，一个点 $u$ 是好的，当且仅当 $|{d^+}_u-{d^-}_u|=1$给每一条边定向，使得图上好的点最多，输出任意一种方案 $n,m\\le3\\times10^5$ 题解令 $c_{w, u}$ 表示点 $u$ 边权为 $w$ 的边的个数，$s_{w, u}$ 表示点 $u$ 边权为 $w$ 的出边的数量减去边权为 $w$ 的入边的数量 答案有上界 $\\sum\\limits_u [c_{1, u}\\bmod 2=1]$，而且这个上界是能够构造达到的 这里考虑欧拉回路对两种边权分别考虑，使得 $s_{1, u}$ 和 $s_{2, u}$ 都尽量接近0 建立新图，对于原图上一条边 $(u, v, w)$，若 $w=1$，则新图上有边 $(u, v)$，否则有边 $(u+n, v+n)$ 现在可以保证 $|s_{w,u}|=c_{w,u}\\bmod 2$ 若 $c_{1, u}\\bmod 2=c_{2, u}\\bmod 2=1$，还需要保证 $\\text{sgn}(s_{1, u})\\not=\\text{sgn}(s_{2, u})$，连边 $(u, u+n)$ 再添加一个节点 $S$，与目前度数为奇数的点，也就是 $c_{1, u}\\bmod 2=1,c_{2, u}\\bmod 2=0$ 或 $c_{1, u}\\bmod 2=0,c_{2, u}\\bmod 2=1$ 的点连边 最后跑一遍欧拉回路定向，把边的方向对应回原图即可 时间复杂度为 $\\Theta(n+m)$ 代码 codeforces submission 145198606","link":"/2022/02/05/cf1610f/"},{"title":"XSY4313 seq","text":"显然有两个 $\\log$ 的做法： \\sum_{i\\le j\\le r_i\\\\r_j-j","link":"/2022/03/19/xsy4313/"},{"title":"XSY4363","text":"有生成函数 f(x,y)=\\prod_{0\\le i","link":"/2022/03/20/xsy4363/"}],"tags":[{"name":"树形DP","slug":"树形DP","link":"/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"除法分块","slug":"除法分块","link":"/tags/%E9%99%A4%E6%B3%95%E5%88%86%E5%9D%97/"},{"name":"根号分治","slug":"根号分治","link":"/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"},{"name":"组合","slug":"组合","link":"/tags/%E7%BB%84%E5%90%88/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"斯特林数","slug":"斯特林数","link":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"二项式定理","slug":"二项式定理","link":"/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"多项式","slug":"多项式","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"杜教筛","slug":"杜教筛","link":"/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"name":"单位根反演","slug":"单位根反演","link":"/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"},{"name":"泰勒展开","slug":"泰勒展开","link":"/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/"},{"name":"欧拉回路","slug":"欧拉回路","link":"/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"根号算法","slug":"根号算法","link":"/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","link":"/categories/%E6%A0%91/"},{"name":"图论","slug":"图论","link":"/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"分块","slug":"根号算法/分块","link":"/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E5%88%86%E5%9D%97/"},{"name":"树形DP","slug":"树/树形DP","link":"/categories/%E6%A0%91/%E6%A0%91%E5%BD%A2DP/"},{"name":"根号分治","slug":"根号算法/根号分治","link":"/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"},{"name":"组合","slug":"数学/组合","link":"/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"},{"name":"网络流","slug":"图论/网络流","link":"/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"多项式","slug":"多项式","link":"/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"数论","slug":"数学/数论","link":"/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"数据结构/线段树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"欧拉回路","slug":"图论/欧拉回路","link":"/categories/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"}]}