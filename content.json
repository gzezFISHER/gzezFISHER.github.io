{"pages":[{"title":"404 not found","text":"404","link":"/404.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"我的洛谷账号: FISHER_ Github: gzezFISHER","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"CF1118F2 Tree Cutting (Hard Version)","text":"题意 给定一个有 个节点的树，节点可能有颜色，共 种颜色，编号 ，保证每种颜色都出现. 有的点没有颜色，用 表示. 将其划分为 个联通块，是每个联通块中有且仅有一种颜色，颜色为 的节点可以在任意联通块中. 求有多少中划分的方案 ，答案对 取模 题解 显然有一些点的染色是确定的，一些点可以染上多种颜色，其中所有颜色为 的点与它们的LCA的路径上的点确定染上颜色 先将这些颜色确定的点染色 接下来考虑树形DP 令 表示在以 为根的子树中，最上方联通块不包含已染色点的方案数， 表示在以 为根的子树中，最上方联通块包含已染色点的方案数， 表示点 的颜色 分两种情况讨论转移： 显然 对于 ，再分情况讨论： 能够确定边 是否删去，对 贡献为 若边 删去， 所在联通块必须有色，对 贡献为 若边 保留， 所在联通块必须无色，对 贡献为 总贡献为 综上， 类似的， 对于 ，枚举 继承哪一个儿子节点的颜色，即 对这条式子维护 的前缀积和后缀积即可 总的时间复杂度 到 ，取决于求LCA的算法 代码 codeforces submission 143330738","link":"/2022/01/27/cf1118f2/"},{"title":"CF1039D You Are Given a Tree","text":"题意 给定一棵有 个节点的树. 对于满足 的每一个 ，把树分成若干条包含 个顶点的链，其中每个点最多属于一条链，问最多能分得几条链 题解 考虑 固定时怎么做 贪心 对于一个点，如果在它的子树内有一条经过该点且不经过以被使用点的链，那么将这条链计入答案并将该点标记为使用过 简单的证明： 对于点 满足在其子树内有一条经过该点且不经过以被使用点的链，如果这条链不计入答案，而是选取一条经过 的但不全在 子树中的链，这样划分的链数不会增加，还会占用点 子树外的点 令 表示 时的答案，显然有 类似除法分块， 一共只有 种取值 因此对于每一种取值二分右端点，时间复杂度为 ，不足以通过此题 考虑对前 项直接暴力，只对后面的 种取值二分 时间复杂度为 ， 取 时有最优复杂度 代码 codeforces submission 144337474","link":"/2022/01/29/cf1039d/"},{"title":"CF1436F Sum Over Subsets","text":"题意 给出一个可重集 ，值为 的元素有 个 有两个集合 满足 这两个集合的权值 求所有可能的集合对 的权值之和 题解 考虑令 表示满足 时的答案， 表示满足 时的答案 有 求出 以后，可以莫比乌斯反演得到 即 所以答案 接下来考虑求 先构造集合 有 考虑每一对 对 的贡献 在集合 中但不再集合 中的元素称为特殊元素，在集合 和 中的称为普通元素 分两种情况讨论： 是同一个元素 显然 是普通元素 那么我们从剩下 个元素中选出一个特殊元素，再从剩下的 个元素中任选若干个作为普通元素 有 种方案，产生 的贡献 是不同的元素，注意是元素不同，不是值不同 显然 是普通元素 若 是普通元素，类似的有 种方案 若 是特殊元素，在剩下的 个元素中任选作为普通元素，有 种方案 共 种方案，产生贡献 回到本题，由于 特别大，把值相同的元素放在一起考虑 相同值 之间的贡献有两种 同元素 乘上值为 的元素个数 有贡献 不同元素 有贡献 不同的值 之间的贡献 类似的 复杂度为调和级数 代码 codeforces submission 144913462","link":"/2022/02/02/cf1436f/"},{"title":"CF1588F Jumping Through the Array","text":"题意 有一个长度为 的数组 和一个长度为 的排列 ，对于每一个 有一条有向边 . 有 次如下三种操作： 1 l r，询问 2 v x，将所有从 出发能到达的节点的编号在 上对应的值加上 3 x y，交换 和 题解 考虑对操作序列分块，每块结束后暴力重构 由于 始终是一个排列，在任一时刻所有边构成的图是若干个环 注意到每次操作3会更改两个点的出边，在同一个操作序列的块中的这样的点将图分为若干色块，每个色块在这个操作序列的块中都不会发生改变 由于关键点只有 个，色块也只有 个 操作2就是在所有能到达的色块上打一个加法标记 考虑操作1 对于每一个询问我们将其差分为两个前缀和，也就是一个块内一共询问 个前缀和 由于一共只有 种颜色和 个有用的前缀和，可以 预处理出在所有用到的前缀和中每种颜色的点的个数 重构的时候，每个数加上它所在色块的加法标记 每块预处理的时间复杂度为 ，所有修改与询问的时间复杂度为 ，因此总时间复杂度为 代码 codeforces submission 144997997","link":"/2022/02/03/cf1588f/"},{"title":"CF1610F Mashtali: a Space Oddysey","text":"题意 现在有一个由 个节点 条边组成的无向图，每条边的边权 令 表示 所有出边的权值和，令 表示 所有入边的权值和，一个点 是好的，当且仅当 给每一条边定向，使得图上好的点最多，输出任意一种方案 题解 令 表示点 边权为 的边的个数， 表示点 边权为 的出边的数量减去边权为 的入边的数量 答案有上界 ，而且这个上界是能够构造达到的 考虑欧拉回路 建立新图，对于原图上一条边 ，若 ，则新图上有边 ，否则有边 可以保证 若 ，还要保证 ，连边 再添加一个节点 ，与目前度数为奇数的点，也就是 或 的点连边 最后跑一遍欧拉回路定向，把边的方向对应回原图 时间复杂度为 代码 codeforces submission 145198606","link":"/2022/02/05/cf1610f/"},{"title":"CF802O April Fools&#39; Problem (hard)","text":"题意 有 道题，第 天可以花费 准备一道题，花费 打印一道题，每天最多准备一道题，打印一道题，准备的题可以留到以后打印，求打印 道题的最小花费. 题解 显然可以费用流解决 考虑优化费用流 引理 初始不含负圈的图在费用流的增广过程中不会出现负圈 根据引理得，每次增广的增广路都是一条形如 的路径，一共增广 次 设 表示在残流网络上 点向 的流量，则一条增广路合法当且仅当 这两条边有流量且满足下列两个条件之一： 尝试用线段树来模拟这一过程，对于每一个区间 ，维护 的最小值 ， 的最小值 ，从 到 有流量的最小 ，从 到 有流量的最小 ，从左到右的最小费用流 ，从右到左的最小费用流 ，从 到 的流量 每找到一条增广路，在线段树上更新流量并把 设为 这时候发现这个做法是不可行的，因为没法对流量快速地区间修改 发现 的值总是 ，于是使 ， 和 取整个区间每条边的流量都减去 之后的值，这样不影响区间 的答案，而且区间修改时只需要更新 为了方便pushup，还需要 表示假设区间内从右到左的每条边都有流量时，从右到左最小的费用 细节详见代码 每次增广的时间复杂度可以做到 ，总时间复杂度为 代码 codeforces submission 143973639","link":"/2022/01/26/cf802o/"},{"title":"CF717A Festival Organization","text":"题意 一个合法的串定义为：长度在 之间，且只含 ，并且不存在连续 个或更多的 现在要选出 个长度相同的不同的合法的串，问有几种选法，答案模 . 题解 设 表示长度为 , 以 结尾的合法串个数 有 即 所以答案 考虑带入斐波那契数的通项，令 等比数列求和快速计算式子后面部分 代码 codeforces submission 137205589","link":"/2022/01/26/cf717a/"},{"title":"CF997D Cycles in product","text":"题意 给你大小为 ​的两棵树 ​，构造一张新图，该图中每一个点的编号为 。如果在 ​中， ​和 ​之间有边，那么在该图上，对于任意 ， 和 之间有边。同样，如果在 ​中， ​和​之间有边，那么在图上，对于任意 ， 和 之间有边 求这个图上长度为 的环有多少个，环可以不为简单环，起始点或方向不同的环视为不同的环 ，答案对 取模. 题解 上一个长度为 的环和 上一个长度为 的环以不同方式组合对应图上 个环 即答案为 ，其中 表示 上长度为 的环的个数， 表示 上长度为 的环的个数 我们把每个点作为起始点分别计算，考虑到树上所有的环长度均为偶数，令 表示以 为起始点，长度为 的环的个数，有 由于从父亲节点往儿子节点转移十分困难，不妨对于每个点只考虑在其子树中的环然后换根DP 考虑转移 令 ，有 换根DP维护 ，再通过 计算 足以通过此题 代码 codeforces submission 143516835 优化 复杂度瓶颈在 的计算，考虑优化这一过程 令 ，有 令 ，有 多项式快速幂和求逆可以做到 的复杂度","link":"/2022/01/26/cf997d/"},{"title":"LUOGU P4119 Ynoi2018 未来日记","text":"题意 有一个长度为 的序列，共 次操作： 1 l r x y，把区间 内所有 变成 ； 2 l r k，查询区间 内第 小值. ，任何时刻 题解 考虑分块 对序列和值域同时分块，维护 表示前 块内值 的个数， 表示序列前 块内值在值域第 块内的个数 对于散块每次查询构造 表示在散块中值为 的个数， 表示散块中值在值域第 块内的个数 查询时对整块差分再加上散块的贡献，即可 地查询区间 内值为 的个数和区间内值在值域第 块中的个数 先枚举 小值在值域中的哪一块，再枚举 小值是该块中的哪一个值，一次查询的时间复杂度为 考虑修改 对于散块直接暴力修改 对于每个整块维护一个类似并查集的东西 给块内每一个值一个标号 ，颜色相同的有相同的标号，维护值对标号的映射 和值对标号的映射 把 变成 时的两种情况： 块内没有 修改两个映射 块内有 暴力修改，通过势能分析证明总的暴力修改复杂度为 总的时间复杂度为 代码 P4119.cpp &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000, maxvs = 316;const int maxs = 360, maxc = 278;int cnt;int a[maxn + 5];int lp[maxc + 5], rp[maxvs + 5];int bl[maxn + 5];int vlp[maxvs + 5];int vbl[maxn + 5];int sum[maxc + 5][maxn + 5];int blsum[maxc + 5][maxvs + 5];int rep[maxc + 5][maxn + 5];int col[maxc + 5][maxs + 5];int id[maxn + 5];int ccnt[maxc + 5];void buildUnion(int bid) { for (int i = 1; i &lt;= ccnt[bid]; i++) rep[bid][col[bid][i]] = 0; ccnt[bid] = 0; for (int i = lp[bid]; i &lt;= rp[bid]; i++) { if (rep[bid][a[i]] == 0) { rep[bid][a[i]] = ++ccnt[bid]; col[bid][ccnt[bid]] = a[i]; } id[i] = rep[bid][a[i]]; }}void reset(int bid) { for (int i = lp[bid]; i &lt;= rp[bid]; i++) a[i] = col[bid][id[i]];}void build(int n) { int siz = min(n, int(sqrt(1.3 * n))); cnt = ceil(1. * n / siz); for (int i = 1; i &lt;= n; i++) bl[i] = (i - 1) / siz + 1; for (int i = 1; i &lt;= cnt; i++) { lp[i] = (i - 1) * siz + 1; rp[i] = min(n, i * siz); } for (int i = 1; i &lt;= maxn; i++) vbl[i] = (i - 1) / maxvs + 1; for (int i = 1; i &lt;= maxvs + 1; i++) vlp[i] = (i - 1) * maxvs + 1; for (int i = 1; i &lt;= cnt; i++) { for (int j = 1; j &lt;= maxn; j++) sum[i][j] = sum[i - 1][j]; for (int j = 1; j &lt;= maxvs + 1; j++) blsum[i][j] = blsum[i - 1][j]; for (int j = lp[i]; j &lt;= rp[i]; j++) { sum[i][a[j]]++; blsum[i][vbl[a[j]]]++; } buildUnion(i); }}int tmp[maxn + 5], bltmp[maxvs + 5];void add(int l, int r, int delta) { for (int i = l; i &lt;= r; i++) { tmp[a[i]] += delta; bltmp[vbl[a[i]]] += delta; }}int query(int l, int r, int k) { int lb = bl[l], rb = bl[r]; int res; if (lb == rb) { reset(lb); copy(a + l, a + r + 1, tmp + l); nth_element(tmp + l, tmp + l + k - 1, tmp + r + 1); res = tmp[l + k - 1]; fill(tmp + l, tmp + r + 1, 0); } else { reset(lb); reset(rb); add(l, rp[lb], 1); add(lp[rb], r, 1); int i = 1, delta; for (; k - (delta = bltmp[i] + blsum[rb - 1][i] - blsum[lb][i]) &gt; 0; i++) k -= delta; int j = vlp[i]; for (; k - (delta = tmp[j] + sum[rb - 1][j] - sum[lb][j]) &gt; 0; j++) k -= delta; res = j; add(l, rp[lb], -1); add(lp[rb], r, -1); } return res;}void change(int l, int r, int x, int y, int bid) { int chcnt = 0; for (int i = l; i &lt;= r; i++) { if (a[i] == x) { a[i] = y; chcnt++; } } sum[bid][x] -= chcnt; sum[bid][y] += chcnt; blsum[bid][vbl[x]] -= chcnt; blsum[bid][vbl[y]] += chcnt;}void changeBlock(int l, int r, int x, int y, int bid) { reset(bid); change(l, r, x, y, bid); buildUnion(bid);}void modify(int l, int r, int x, int y) { int lb = bl[l], rb = bl[r]; if (x == y || sum[rb][x] - sum[lb - 1][x] == 0) return; for (int i = cnt; i &gt;= lb; i--) { sum[i][x] -= sum[i - 1][x]; sum[i][y] -= sum[i - 1][y]; blsum[i][vbl[x]] -= blsum[i - 1][vbl[x]]; blsum[i][vbl[y]] -= blsum[i - 1][vbl[y]]; } if (lb == rb) changeBlock(l, r, x, y, lb); else { changeBlock(l, rp[lb], x, y, lb); changeBlock(lp[rb], r, x, y, rb); for (int i = lb + 1; i &lt; rb; i++) { if (sum[i][x] == 0) continue; if (sum[i][y] == 0) { col[i][rep[i][x]] = y; swap(rep[i][y], rep[i][x]); blsum[i][vbl[y]] += sum[i][x]; blsum[i][vbl[x]] -= sum[i][x]; sum[i][y] = sum[i][x]; sum[i][x] = 0; } else changeBlock(lp[i], rp[i], x, y, i); } } for (int i = lb; i &lt;= cnt; i++) { sum[i][x] += sum[i - 1][x]; sum[i][y] += sum[i - 1][y]; blsum[i][vbl[x]] += blsum[i - 1][vbl[x]]; blsum[i][vbl[y]] += blsum[i - 1][vbl[y]]; }}int main() { int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); build(n); for (int i = 1; i &lt;= m; i++) { int op, l, r; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if (op == 1) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); modify(l, r, x, y); } else { int k; scanf(\"%d\", &amp;k); printf(\"%d\\n\", query(l, r, k)); } }}","link":"/2022/02/01/luogu4119/"},{"title":"LOJ6241 性能优化","text":"题意 求 多组数据 题解 令 则有 根据杜教筛，由 ，有 即 带回原式得","link":"/2021/01/15/loj6241/"},{"title":"UOJ435 Simple Tree","text":"题意 有一棵有根树，根为 ，点有点权. 现在有 次操作，操作有3种： - 1 x y w，将 到 的路径上的点点权加上 (其中 )； - 2 x y，询问在 到 的路径上有多少个点点权 ； - 3 x，询问在 的子树里的点有多少个点点权 . 强制在线，点权 题解 先考虑序列上的分块做法 每一块内部预先排好序，维护在排好序的块内下标最小的大于零点的下标 以及对于块中每个数第一个严格大于和小于该数的位置 和 查询的时候，整块用右端点减去 即可得到答案 散块暴力统计 修改的时候，整块修改零点，然后尝试让 往 或 跳 散块暴力修改并归并排序 把序列问题放在树上，一个显然的想法是树链剖分，，不足以通过此题 其实在树链剖分的情况下 的块长不是最优的 每次链的询问和修改，涉及的整块是 级别的，然而涉及的散块元素个数是 级别的，因此块长 时取到最优复杂度 考虑对每条链单独分块 下面证明链操作的时间复杂度是 不妨考虑一条竖直的链 设这条链从上到下依次经过的重链分别为 由树链剖分的性质，有 即复杂度为 下面考虑子树查询 每条重链按链顶dfn序排序，发现每棵子树都是由一条重链的一部分和排序后连续的完整重链构成 修改时，对于 条被修改的重链，在树状数组上更新答案 子树询问时，区间查询即可 总复杂度为 代码 uoj435.cpp &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000, maxs = 200;int n, q, T;int val[maxn + 5];vector&lt;int&gt; g[maxn + 5];int stamp;int dep[maxn + 5];int fa[maxn + 5];int heavy_son[maxn + 5];int siz[maxn + 5];int tp[maxn + 5], bt[maxn + 5];int id[maxn + 5];int lnk[maxn + 5];int lcnt;int lid[maxn + 5];int minl[maxn + 5], maxl[maxn + 5];void dfs1(int u, int f) { fa[u] = f; dep[u] = dep[f] + 1; siz[u] = 1; for (size_t i = 0; i &lt; g[u].size(); i++) { int v = g[u][i]; if (v == f) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[heavy_son[u]]) heavy_son[u] = v; }}void dfs2(int u, int f, int top) { id[u] = ++stamp; lnk[u] = top; if (u == top) tp[++lcnt] = id[u]; if (heavy_son[u] == 0) bt[lcnt] = id[u]; lid[u] = lcnt; minl[u] = lcnt + 1; if (heavy_son[u]) dfs2(heavy_son[u], u, top); for (size_t i = 0; i &lt; g[u].size(); i++) { int v = g[u][i]; if (v == f || v == heavy_son[u]) continue; dfs2(v, u, v); } maxl[u] = lcnt;}inline int lowbit(int x) { return x &amp; (-x);}struct fenwic { int t[maxn + 5]; void modify(int x, int y) { while (x &lt;= lcnt) { t[x] += y; x += lowbit(x); } } int query_(int x) const { int res = 0; while (x &gt; 0) { res += t[x]; x -= lowbit(x); } return res; } int query(int l, int r) const { return query_(r) - query_(l - 1); }} bit;struct block { int cnt; int tot[maxn + 5]; int a[maxn + 5]; int blg[maxn + 5]; int zero[maxn + 5]; int lp[maxn + 5], rp[maxn + 5], pts[maxn + 5]; pair&lt;int, int&gt; tmp1[maxs + 5], tmp2[maxs + 5]; pair&lt;int, int&gt; sorted[maxn + 5]; int nxt[maxn + 5], lst[maxn + 5], lpts[maxn + 5]; void resize(int arr[], int l, int r, int lk) { int len = r - l + 1; int bsiz = ceil(sqrt(.12 * len)); int bcnt = ceil(1. * len / bsiz); for (int i = l; i &lt;= r; i++) { a[i] = arr[i]; sorted[i] = pair&lt;int, int&gt;(arr[i], i); } for (int i = cnt + 1; i &lt;= cnt + bcnt; i++) { lp[i] = l + (i - cnt - 1) * bsiz; rp[i] = min(r, l + (i - cnt) * bsiz - 1); for (int j = lp[i]; j &lt;= rp[i]; j++) blg[j] = i; sort(sorted + lp[i], sorted + rp[i] + 1); calcNxtLst(i); tot[lk] += rp[i] - pts[i] + 1; } cnt += bcnt; } void calcNxtLst(int bid) { for (int i = rp[bid], j = rp[bid] + 1; i &gt;= lp[bid]; i--) { while (i &gt; lp[bid] &amp;&amp; sorted[i].first == sorted[i - 1].first) i--; nxt[i] = j; if (j &lt;= rp[bid]) lst[j] = i; else lpts[bid] = i; j = i; } lst[lp[bid]] = lp[bid]; pts[bid] = rp[bid] + 1; for (int i = lp[bid]; i &lt;= rp[bid]; i++) { if (sorted[i].first &gt; zero[bid]) { pts[bid] = i; break; } } } void mergeSort(int bid, int l, int r, int delta, int lk) { tot[lk] += pts[bid]; for (int i = l; i &lt;= r; i++) a[i] += delta; int cnt1 = 0, cnt2 = 0; for (int i = lp[bid]; i &lt;= rp[bid]; i++) { if (sorted[i].second &gt;= l &amp;&amp; sorted[i].second &lt;= r) tmp1[++cnt1] = pair&lt;int, int&gt;(sorted[i].first + delta, sorted[i].second); else tmp2[++cnt2] = sorted[i]; } merge(tmp1 + 1, tmp1 + cnt1 + 1, tmp2 + 1, tmp2 + cnt2 + 1, sorted + lp[bid]); calcNxtLst(bid); tot[lk] -= pts[bid]; } void modify(int l, int r, int delta, int lk) { int lb = blg[l], rb = blg[r]; if (lb == rb) mergeSort(lb, l, r, delta, lk); else { mergeSort(lb, l, rp[lb], delta, lk); mergeSort(rb, lp[rb], r, delta, lk); for (int i = lb + 1; i &lt; rb; i++) { tot[lk] += pts[i]; zero[i] -= delta; if (pts[i] &gt; rp[i]) { if (sorted[lpts[i]].first &gt; zero[i]) pts[i] = lpts[i]; } else { if (delta == 1) { if (sorted[lst[pts[i]]].first &gt; zero[i]) pts[i] = lst[pts[i]]; } else if (sorted[pts[i]].first &lt;= zero[i]) pts[i] = nxt[pts[i]]; } tot[lk] -= pts[i]; } } } int query(int l, int r) const { int res = 0; int lb = blg[l], rb = blg[r]; if (lb == rb) { for (int i = l; i &lt;= r; i++) if (a[i] &gt; zero[lb]) res++; } else { for (int i = l; i &lt;= rp[lb]; i++) if (a[i] &gt; zero[lb]) res++; for (int i = lp[rb]; i &lt;= r; i++) if (a[i] &gt; zero[rb]) res++; for (int i = lb + 1; i &lt; rb; i++) res += rp[i] - pts[i] + 1; } return res; }} bl;int queryLnk(int x, int y) { int res = 0; while (lnk[x] != lnk[y]) { if (dep[lnk[x]] &lt; dep[lnk[y]]) swap(x, y); res += bl.query(tp[lid[x]], id[x]); x = fa[lnk[x]]; } if (dep[y] &lt; dep[x]) swap(x, y); res += bl.query(id[x], id[y]); return res;}int querySubtree(int x) { return bl.query(id[x], bt[lid[x]]) + bit.query(minl[x], maxl[x]);}void modifyLnk(int x, int y, int delta) { while (lnk[x] != lnk[y]) { if (dep[lnk[x]] &lt; dep[lnk[y]]) swap(x, y); int ori = bl.tot[lid[x]]; bl.modify(tp[lid[x]], id[x], delta, lid[x]); bit.modify(lid[x], bl.tot[lid[x]] - ori); x = fa[lnk[x]]; } if (dep[y] &lt; dep[x]) swap(x, y); int ori = bl.tot[lid[x]]; bl.modify(id[x], id[y], delta, lid[x]); bit.modify(lid[x], bl.tot[lid[x]] - ori);}int main() { scanf(\"%d%d%d\", &amp;n, &amp;q, &amp;T); for (int i = 1; i &lt; n; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } dfs1(1, 0); dfs2(1, 0, 1); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;val[id[i]]); for (int i = 1; i &lt;= lcnt; i++) { bl.resize(val, tp[i], bt[i], i); bit.modify(i, bl.tot[i]); } int lstans = 0; for (int i = 1; i &lt;= q; i++) { int op, x, y, w; scanf(\"%d%d\", &amp;op, &amp;x); if (T == 1) x ^= lstans; if (op == 1) { scanf(\"%d%d\", &amp;y, &amp;w); if (T == 1) y ^= lstans; modifyLnk(x, y, w); } else if (op == 2) { scanf(\"%d\", &amp;y); if (T == 1) y ^= lstans; printf(\"%d\\n\", lstans = queryLnk(x, y)); } else printf(\"%d\\n\", lstans = querySubtree(x)); }}","link":"/2022/01/30/uoj435/"},{"title":"UOJ450 复读机","text":"题意 种球，每种个数必须是 的倍数，共 个，求排成一行的方案数. ，答案对 取模. 题解 单位根反演泰勒展开 ： 二项式定理泰勒展开 ： 多项式定理泰勒展开","link":"/2021/10/16/uoj450/"},{"title":"XSY4313 seq","text":"显然有两个 的做法： 类似三维偏序 考虑一个阈值 ，分别考虑 在区间 和 的情况 这四个东西都可以第一维差分，第二维树状数组做","link":"/2022/03/19/xsy4313/"},{"title":"XSY4366 Stardust的连接","text":"将原图转化为一张 的网格图，原图上一点 有 容易发现有三种边 ， 和 其中 时后两种边会连回第一列 考虑轮廓线DP，可以按行或按列DP，按行的复杂度为 由于有从最后一列连回第一列的边，按列需要枚举最后一列的状态分别DP，复杂度为 两种取较小值得到 事实上按行DP等价于从小到大枚举 ，状压 的匹配状态，这种实现更加简便","link":"/2022/04/02/xsy4366/"},{"title":"XSY4363","text":"有生成函数 单位根反演 定理1： 证明 ，，即 ，即 推论： 定理 定理2： 证明 关于 的方程 和 有相同的根 且次数与最高次项系数一致 定理二项式定理推论 推论 如果不考虑大组合数的话可以做到 组合数分块打阶乘表即可","link":"/2022/03/20/xsy4363/"},{"title":"XSY4370 多区间逆序对","text":"令 先根号分治 的直接树状数组暴力计算， 的分别计算每对区间的贡献，一共有 对 对序列每 个值分一个块，散块中的值至多有 个，提出来暴力计算 然后是整块对一个区间的贡献 (如图1) 差分变成四个整块前缀对序列前缀的贡献，离线下来从前往后扫一遍所有块的前缀 对每个块前缀，维护前缀内值的桶的前缀和，然后再从前往后扫一遍序列的前缀 需要注意整块对整块的贡献被统计两次 (如图2，红色部分)，同样的方法去掉 总时间复杂度为 取 ，，复杂度为 精细实现可以做到空间 xsy4370.cpp &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500000, maxb = 1250;const int B1 = 450, B2 = 400;int n;int blg[maxn + 5];int lp[maxb + 5], rp[maxb + 5];int a[maxn + 5];vector&lt;pair&lt;int, int&gt;&gt; seq[maxn + 5];pair&lt;int, int&gt; q1[maxn + 5];int t[maxn + 5];#define lowbit(x) (x &amp; (-x))void modify(int x, int v) { while (x &lt;= n) { t[x] += v; x += lowbit(x); }}int query(int x) { int res = 0; while (x &gt; 0) { res += t[x]; x -= lowbit(x); } return res;}long long rude(int l) { long long res = 0; int j = 1; for (int i = 1; i &lt;= l; i++) { while (j &lt;= l &amp;&amp; q1[j].first != q1[i].first) modify(q1[j++].second, 1); res += query(q1[i].second - 1); } if (l &lt; n / 500) for (int i = 1; i &lt; j; i++) modify(q1[i].second, -1); else memset(t, 0, sizeof(t)); return res;}struct offline { int id, p, z;};vector&lt;offline&gt; q2[maxb + 5];int sum[maxn + 5];long long pre[maxn + 5];long long ans[maxn + 5];int main() { int Q; scanf(\"%d%d\", &amp;n, &amp;Q); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); int c = ceil(1. * n / B2); for (int i = 1; i &lt;= c; i++) { lp[i] = (i - 1) * B2 + 1; rp[i] = min(n, i * B2); } for (int i = 1; i &lt;= n; i++) blg[i] = (i - 1) / B2 + 1; for (int i = 1; i &lt;= Q; i++) { int m; scanf(\"%d\", &amp;m); seq[i].resize(m); for (int j = 0; j &lt; m; j++) scanf(\"%d%d\", &amp;seq[i][j].first, &amp;seq[i][j].second); if (m &gt; B1) { int cnt = 0; for (int j = 0; j &lt; m; j++) for (int k = seq[i][j].first; k &lt;= seq[i][j].second; k++) q1[++cnt] = {j, a[k]}; ans[i] = rude(cnt); } else { int cnt = 0; for (int j = 0; j &lt; m; j++) { int l = seq[i][j].first, r = seq[i][j].second; if (blg[l] == blg[r]) for (int k = l; k &lt;= r; k++) q1[++cnt] = {j, a[k]}; else { for (int k = l; k &lt;= rp[blg[l]]; k++) q1[++cnt] = {j, a[k]}; for (int k = lp[blg[r]]; k &lt;= r; k++) q1[++cnt] = {j, a[k]}; } } ans[i] = rude(cnt); for (int j = 0; j &lt; m; j++) { int bl1 = blg[seq[i][j].first], br1 = blg[seq[i][j].second] - 1; if (bl1 &gt;= br1) continue; q2[br1].push_back({i, j, 1}); q2[bl1].push_back({i, j, -1}); } } } for (int i = 1; i &lt;= c; i++) { memset(sum, 0, sizeof(sum)); for (int j = 1; j &lt;= rp[i]; j++) sum[a[j]]++; for (int j = 1; j &lt;= n; j++) sum[j] += sum[j - 1]; for (int j = 1; j &lt;= n; j++) { pre[j] = pre[j - 1]; if (j &lt;= rp[i]) pre[j] += rp[i] - sum[a[j]]; else pre[j] += sum[a[j] - 1]; } for (auto q : q2[i]) { int id = q.id, p = q.p, z = q.z; int m = seq[id].size(); for (int j = 0; j &lt; m; j++) { if (j == p) continue; int l = seq[id][j].first, r = seq[id][j].second; ans[id] += z * (pre[r] - pre[l - 1]); int bl2 = blg[l] + 1, br2 = blg[r] - 1; if (j &gt; p &amp;&amp; bl2 &lt;= br2) ans[id] -= z * (pre[rp[br2]] - pre[lp[bl2] - 1]); } } } for (int i = 1; i &lt;= Q; i++) printf(\"%lld\\n\", ans[i]);}","link":"/2022/04/02/xsy4370/"}],"tags":[{"name":"树形DP","slug":"树形DP","link":"/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"除法分块","slug":"除法分块","link":"/tags/%E9%99%A4%E6%B3%95%E5%88%86%E5%9D%97/"},{"name":"根号分治","slug":"根号分治","link":"/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"},{"name":"组合","slug":"组合","link":"/tags/%E7%BB%84%E5%90%88/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"欧拉回路","slug":"欧拉回路","link":"/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"斯特林数","slug":"斯特林数","link":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"二项式定理","slug":"二项式定理","link":"/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/"},{"name":"多项式","slug":"多项式","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"杜教筛","slug":"杜教筛","link":"/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"单位根反演","slug":"单位根反演","link":"/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"},{"name":"泰勒展开","slug":"泰勒展开","link":"/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","link":"/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"根号算法","slug":"根号算法","link":"/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","link":"/categories/%E6%A0%91/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"欧拉回路","slug":"图论/欧拉回路","link":"/categories/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"},{"name":"分块","slug":"根号算法/分块","link":"/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E5%88%86%E5%9D%97/"},{"name":"树形DP","slug":"树/树形DP","link":"/categories/%E6%A0%91/%E6%A0%91%E5%BD%A2DP/"},{"name":"网络流","slug":"图论/网络流","link":"/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"根号分治","slug":"根号算法/根号分治","link":"/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"},{"name":"组合","slug":"数学/组合","link":"/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"},{"name":"数论","slug":"数学/数论","link":"/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"多项式","slug":"多项式","link":"/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"线段树","slug":"数据结构/线段树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]}