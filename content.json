{"pages":[{"title":"404 not found","text":"404","link":"/404.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"我的洛谷账号: FISHER_ Github: gzezFISHER","link":"/about/index.html"}],"posts":[{"title":"CF1118F2 Tree Cutting (Hard Version)","text":"题意给定一个有 $n$ 个节点的树，节点可能有颜色，共 $k$ 种颜色，编号 $1…k$，保证每种颜色都出现. 有的点没有颜色，用 $0$ 表示. 将其划分为 $k$ 个联通块，是每个联通块中有且仅有一种颜色，颜色为 $0$ 的节点可以在任意联通块中. 求有多少中划分的方案. $2\\le k\\le n\\le 3\\times 10^5$，答案对 $998244353$ 取模. 题解我们称将一个点划归一个有且仅有颜色 $c$ 的联通块为将这个点染上颜色 $c$ 显然有一些点的染色是确定的，一些点可以染上多种颜色，其中所有颜色为 $c$ 的点与它们的LCA的路径上的点确定染上颜色 $c$，证明显然 我们先按照如下流程将这些颜色确定的点染色： 找出同一颜色 $c$ 的点的LCA 依次从每个点开始往父亲上跳，一边跳一边染色 跳到一个点已经染色或已经到达LCA即可停止，如果跳到的点已经染上颜色且不为 $c$ 则两种颜色构成的联通块必然重叠，即没有合法方案 接下来考虑树形DP令 $f_{u,0}$ 表示在以 $u$ 为根的子树中，最上方联通块不包含已染色点的方案数，$f_{u,1}$ 表示在以 $u$ 为根的子树中，最上方联通块包含已染色点的方案数，$c_u$ 表示点 $u$ 的颜色 我们分两种情况讨论转移： $c_u\\not=0$ 显然 $f_{u, 0}=0$ 对于 $f_{u, 1}$，再分情况讨论： $v\\in\\text{son}_u,c_v\\not=0$ 能够确定边 $(u, v)$ 是否删去，对 $f_{u, 1}$ 贡献为 $f_{v, 1}=f_{v, 0}+f_{v, 1}$ $v\\in\\text{son}_u,c_v=0$ 若边 $(u, v)$ 删去，$v$ 所在联通块必须有色，否则该联通块将不包含任何一种颜色，对 $f_{u, 1}$ 贡献为 $f_{v, 1}$ 若边 $(u, v)$ 保留，$v$ 所在联通块必须无色，否则该联通块将包含多种颜色，对 $f_{u, 1}$ 贡献为 $f_{v, 0}$ 总贡献为 $f_{v, 0}+f_{v, 1}$ 综上，$f_{u, 1}=\\prod\\limits_{v\\in\\text{son}_u}f_{v, 0}+f_{v, 1}$ $c_u=0$ 类似的，$f_{u, 0}=\\prod\\limits_{v\\in\\text{son}_u}f_{v, 0}+f_{v, 1}$ 对于 $f_{u, 1}$，我们枚举 $u$ 继承哪一个儿子节点的颜色，即 $f_{u, 1}=\\sum\\limits_{v_1\\in\\text{son}_u}f_{v_1, 1}\\times\\prod\\limits_{v_2\\in\\text{son}_u,v_2\\not=v_1}f_{v_2, 0}+f_{v_2, 1}$ 对于这条式子我们维护 $f_{v, 0}+f_{v, 1}$ 的前缀积和后缀积即可 总的时间复杂度 $\\Theta(n)$ 到 $\\Theta(n\\log n)$，取决于求LCA的算法 代码 codeforces submission 143330738","link":"/2022/01/27/cf1118f2/"},{"title":"CF1039D You Are Given a Tree","text":"题意给定一棵有 $n$ 个节点的树. 对于满足 $1\\le k\\le n$ 的每一个 $k$，把树分成若干条包含 $k$ 个顶点的链，其中每个点最多属于一条链，问最多能分得几条链. $n\\le 10^5$ 题解考虑 $k$ 固定时怎么做 我们自下而上贪心，对于一个点，如果在它的子树内有一条经过该点且不经过以被使用点的链，那么我们就将这条链计入答案并将该点标记为使用过 简单证明一下：对于点 $u$ 满足在其子树内有一条经过该点且不经过以被使用点的链，如果这条链不计入答案，而是选取一条经过 $u$ 的但不完全在 $u$ 子树中的链，这样划分的链数不会增加，反而会占用这条链在点 $u$ 子树外的点因此，按照上述方法贪心是最优的 令 $f_i$ 表示 $k=i$ 时的答案，显然有 $f_i\\le\\lfloor\\frac{n}{i}\\rfloor$ 类似除法分块，$f_i$ 一共只有 $\\mathcal{O}(\\sqrt{n})$ 种取值证明如下： $i\\le \\sqrt{n}$ 显然只有不超过 $\\sqrt{n}$ 种取值 $i&gt;\\sqrt{n}$ $f_i&lt;\\lfloor\\frac{n}{\\sqrt{n}}\\rfloor=\\sqrt{n}$ 显然也只有不超过 $\\sqrt{n}$ 种取值 因此我们对于每一种取值二分右端点，时间复杂度为 $\\mathcal{O}(n\\sqrt{n}\\log n)$，不足以通过此题 观察到前几种取值比较密集，对每种取值二分是很浪费的，考虑对前 $T$ 项直接暴力，只对后面的 $\\mathcal{O}(\\frac{n}{T})$ 种取值二分 时间复杂度为 $\\mathcal{O}(nT+\\frac{n}{T}\\log n)$，$T$ 取 $\\sqrt{n\\log n}$ 时有最优复杂度 $\\mathcal{O}(n\\sqrt{n\\log n})$ 细节实现的时候注意常数，特别是不要每次贪心都dfs一遍，可以直接在dfs序上贪心 代码 codeforces submission 144337474","link":"/2022/01/29/cf1039d/"},{"title":"CF1436F Sum Over Subsets","text":"题意给出一个可重集 $S$，值为 $i$ 的元素有 $freq_i$ 个有两个集合 $A,B$ 满足 $B\\subset A\\subseteq S$ $|B|=|A|-1$ $\\gcd\\limits_{x\\in A}x=1$ 称这两个集合的权值 $w(A,B)=\\sum\\limits_{x\\in A}x\\sum\\limits_{y\\in B}y$求所有可能的集合对 $(A, B)$ 的权值之和 $1\\le a_i\\le10^5,freq_i\\le10^9$ 题解$\\gcd_{x\\in A}x=1$ 是一个棘手的条件 考虑令 $f_i$ 表示满足 $\\gcd\\limits_{x\\in A}x=i$ 时的答案，$g_i$ 表示满足 $i\\mid\\gcd_{x\\in A}x$ 时的答案有 $g_i=\\sum\\limits_{i\\mid j}f_j$求出 $g$ 以后，可以莫比乌斯反演得到 $f$即 $f_i=\\sum\\limits_{j\\mid i}\\mu(j)\\times g_j$ 所以答案 $\\text{Ans}=\\sum\\limits_{1\\le i}\\mu(i)\\times g_i$ 接下来考虑求 $g_i$ 先构造集合 $S’=\\{x|x\\in S,i\\mid x\\}$有 \\begin{align*} g_i&=\\sum_{B\\subset A\\subseteq S',|B|=|A|-1}w(A,B)\\\\ &=\\sum_{B\\subset A\\subseteq S',|B|=|A|-1}\\sum_{x\\in A}\\sum_{y\\in B}x\\times y \\end{align*}我们考虑每一对 $(x\\in A, y\\in B)$ 对 $g_i$ 的贡献 称在集合 $A$ 中但不再集合 $B$ 中的元素为特殊元素，在集合 $A$ 和 $B$ 中的为普通元素分两种情况讨论： $x, y$ 是同一个元素显然 $x$ 是普通元素那么我们从剩下 $|S’|-1$ 个元素中选出一个特殊元素，再从剩下的 $|S’|-2$ 个元素中任选若干个作为普通元素有 $(|S’|-1)\\times 2^{|S’|-2}$ 种方案，产生 $(|S’|-1)\\times 2^{|S’|-2}\\times x^2$ 的贡献 $x, y$ 是不同的元素，注意是元素不同，不是值不同显然 $y$ 是普通元素若 $x$ 是普通元素，类似的有 $(|S’|-2)\\times 2^{|S’|-3}$ 种方案若 $x$ 是特殊元素，在剩下的 $|S’|-2$ 个元素中任选作为普通元素，有 $s^{|S’|-2}$ 种方案共 $(|S’|-2)\\times 2^{|S’|-3}+s^{|S’-2|}$ 种方案，产生贡献 $[(|S’|-2)\\times 2^{|S’|-3}+s^{|S’|-2}]\\times x\\times y$ 回到本题，由于 $freq$ 特别大，我们把值相同的元素放在一起考虑相同值 $x$ 之间的贡献有两种 同元素套用上面同元素的贡献，乘上值为 $x$ 的元素个数即可即有贡献 $(|S’|-1)\\times 2^{|S’|-2}\\times x^2\\times freq_x$ 不同元素套用上面不同元素的贡献即有贡献 $[(|S’|-2)\\times 2^{|S’|-3}+s^{|S’|-2}]\\times x^2\\times freq_x\\times (freq_x-1)$ 不同的值 $x, y$ 之间的贡献类似的 $[(|S’|-2)\\times 2^{|S’|-3}+s^{|S’|-2}]\\times x\\times y\\times freq_x\\times freq_y$ 直接求 $\\sum\\limits_{x,y\\in S’,x\\not =y}[(|S’|-2)\\times 2^{|S’|-3}+s^{|S’|-2}]\\times x\\times y\\times freq_x\\times freq_y$ 显然时间上不能接受 稍稍转化一下 \\begin{align*} &\\sum_{x,y\\in S',x\\not =y}[(|S'|-2)\\times 2^{|S'|-3}+s^{|S'|-2}]\\times x\\times y\\times freq_x\\times freq_y\\\\ =&[(|S'|-2)\\times 2^{|S'|-3}+s^{|S'|-2}]\\sum_{x,y\\in S',x\\not =y}x\\times freq_x\\times y\\times freq_y\\\\ =&[(|S'|-2)\\times 2^{|S'|-3}+s^{|S'|-2}][(\\sum_{x\\in S'}x\\times freq_x)^2-\\sum_{x\\in S'}(x\\times freq_x)^2] \\end{align*}至此我们得到了一个调和级数时间复杂度的算法，即 $\\Theta(n\\log n)$ 细节计算 $|S’|$ 时不要直接模 $998244353$，因为它要放在指数上 代码 codeforces submission 144913462","link":"/2022/02/02/cf1436f/"},{"title":"CF1588F Jumping Through the Array","text":"题意有一个长度为 $n$ 的数组 $a$ 和一个长度为 $n$ 的排列 $p$，对于每一个 $i$ 有一条有向边 $(i, p_i)$.有 $q$ 次如下三种操作： 1 l r，询问 $\\sum\\limits_{l\\le i\\le r}a_i$ 2 v x，将所有从 $v$ 出发能到达的节点的编号在 $a$ 上对应的值加上 $x$ 3 x y，交换 $p_x$ 和 $p_y$ $n,q\\le2\\times 10^5$ 题解考虑分块 显然对序列分块是没有用的，考虑经典的对操作序列分块的做法也就是说，只有在处理完一块时暴力更新 $a$，查询时考虑本块内的修改的贡献，再通过 $a$ 计算其他块的贡献 由于 $p$ 始终是一个排列，在任一时刻所有边构成的图由若干个环组成 注意到每次操作3会更改两个点的出边，我们称这样的点为关键点这些关键点将图分为若干部分，每部分由一个关键点和所有不经过其他关键点能到达该关键点的点组成，成为色块，如图 (实心的为关键点)在这一块中任一时刻的图上，这些色块是一个整体，可以放在一起考虑 由于关键点只有 $\\mathcal{O}(\\sqrt{n})$ 个，色块也只有 $\\mathcal{O}(\\sqrt{n})$ 个 对于操作2从 $v$ 开始遍历色块，在所有能到达的色块上打一个加法标记即可关于色块的遍历，我们每次跳到块中的关键点，然后沿着它的出边到达下一个色块，直到回到了最开始的色块需要特别注意的是，不是所有的点都能被色块包含，为了避免 $v$ 不属于任何色块，我们将所有 $v$ 也设为关键点 对于操作3直接更改出边即可 现在考虑操作1对于每一个询问我们将其差分为两个前缀和，也就是一个块内一共询问 $\\mathcal{O}(\\sqrt{n})$ 个前缀和，称为有意义的前缀和由于一共只有 $\\mathcal{O}(\\sqrt{n})$ 种颜色和 $\\mathcal{O}(\\sqrt{n})$ 个有意义的前缀和，可以 $\\Theta(n)$ 预处理出在所有有意义的前缀和中每种颜色的点的个数具体方法是从前到后枚举 $n$ 个前缀，维护每种颜色各出现多少次，遇到有意义的前缀就将出现次数记下询问的时候枚举所有颜色，由每种颜色的出现次数乘上该颜色的加法标记即可得到块内的贡献 最后是 $a$ 数组的重构，每个数加上它所在色块的加法标记即可为了询问方便，对 $a$ 做一次前缀和 每块预处理的时间复杂度为 $\\Theta(n\\sqrt{n})$，所有修改与询问的时间复杂度为 $\\mathcal{O}(n\\sqrt{n})$，因此总时间复杂度为 $\\Theta(n\\sqrt{n})$ 代码 codeforces submission 144997997","link":"/2022/02/03/cf1588f/"},{"title":"CF1633E Spanning Tree Queries","text":"题意有一个由 $n$ 个点 $m$ 条边组成的无向带权联通图，有 $k$ 个询问.每次询问给出一个 $x$，对于每一条边，重新定义边权为 $|w-x|$ ($w$ 为原边权)，求新图上的最小生成树的边权和 $n\\le 50, m\\le 300, k\\le 10^7$ 题解发现存在区间使得 $x$ 在区间内变化时，边权和可以表示为 $a+bx$，其中 $a$，$b$ 为常数 这样的区间需要满足的性质是，当 $x$ 在区间内变化时，图上的每条边大小关系都不会改变 (由kruskal，确定最小生成树上有哪些边)，且原边权 $w$ 与 $x$ 的大小关系不会改变 (可以打开绝对值) 显然这样的区间个数是 $\\mathcal{O}(m^2)$ 级别的，下面给出证明 我们构造这样的区间根据上面两个条件，令临界点 $p$ 使得 $\\exists i, j$ 满足 $|w_i-p|&gt;|w_j-p|$ 且 $|w_i-(p+1)|\\le|w_j-(p+1)|$或 $\\exists i$ 满足 $w_i\\ge p$ 且 $w_i&lt;p+1$即 $p=\\lfloor\\frac{w_i+w_j-1}{2}\\rfloor$ 或 $w_i$ 对所有临界点排序，相邻两个临界点 $p_1, p_2$ 之间的区间 $(p_1, p_2]$ 就是我们所构造的区间，显然这样的区间是满足上面条件的不同的 $p$ 只有 $\\mathcal{O}(m^2)$ 种，对应的区间个数也只有 $\\mathcal{O}(m^2)$ 个 按证明中的构造方法构造出所有区间对于每个区间，打开边权的绝对值，然后含参跑kruskal，得到 $a+bx$ 形式的答案查询时二分 $x$ 所在的区间，带入 $x$ 求值即可 总的时间复杂度为 $\\mathcal{O}(m^3\\log m+k)$ 代码 codeforces submission 144838318","link":"/2022/02/01/cf1633e/"},{"title":"CF442D Adam and Tree","text":"题意彩色树是边有颜色的有根树，其中每一种颜色的边集构成一条链.定义一棵彩色树的权值为所有节点到根节点路径上不同颜色的数量的最大值.现在有一棵不断变化的树，一开始只有1号点 (根节点)，接下来每个时刻长出一个新点，求每一时刻树的权值 长出的节点数 $n\\le10^5$ 题解先考虑树静止时怎么做 发现必然存在一种最优方案，其中任意一种颜色的边集构成的链都是竖直的 (即以一个点与其祖先为顶点)，证明是所有其他的最优方案都可以转化为这种方案 令 $val_u$ 表示点 $u$ 的子树与 $u$ 到父亲的边构成的树的最小权值 (如图，$val_{v_1}$ 为红色树的最小权值，$val_{v_2}$ 为蓝色树的最小权值)发现 $val_u$ 对应的树包含所有 $val_v,v\\in\\text{son}_u$ 对应的树，再加上 $u$ 到其父亲的边 考虑 $u$ 到其父亲的边如何选择颜色我们找出 $val_v$ 最大的 $v$ 记为 $maxv_u$，让 $u$ 到其父亲的边继承边 $(u, maxv_u)$ 的颜色，显然这样是最优的即 val_u=\\max\\{\\max_{v\\in\\text{son}_u,v\\not=maxv_u}val_v+1, val_{maxv_u}\\}我们记下 $val_v$ 的最大值 $max_u$，非严格次大值 $secmax_u$于是有 val_u=\\max\\{max_u, secmax_u+1\\}DP即可，注意答案为 $max_1$ 每次加点，我们从新加的点不断向上更新，这样的时间复杂度是 $\\mathcal{O}(n^2)$，不足以通过此题 考虑做一点小优化我们在向上跳的过程中，如果已经无法更新 $val$，那么再往上跳也无法更新此时停下即可 下面证明这样做复杂度是 $\\mathcal{O}(n\\log n)$ 的 时间复杂度即为更新 $val$ 的次数，即 $T(n)=\\sum\\limits_{1\\le i\\le n}val_i$$val_i$ 的上界是 $\\log_2 n$我们通过构造来证明，实际上并不需要我们自己构造，因为树链剖分已经帮我们构造好了 代码 codeforces submission 144894116","link":"/2022/02/01/cf442d/"},{"title":"CF1458C Latin Square","text":"题意给出一个 $n\\times n$ 的矩阵，每行每列都是一个 $[1, n]$ 的排列，有 $m$ 次操作 U 表示整个矩阵循环下移一格 D 表示整个矩阵循环上移一格 L 表示整个矩阵循环左移一格 R 表示整个矩阵循环右移一格 I 表示把矩阵每一行变为原来排列的逆 R 表示把矩阵每一列变为原来排列的逆 多组测试数据，$1\\le T\\le 1000$，$1\\le n, m$，$\\sum n\\le 1000,\\sum m\\le 10^5$ 题解考虑排列逆的含义 一个排列 $a$ 可以表示为若干个点 $(i, a_i)$根根据排列逆的定义，我们可以发现 $a$ 的逆 $a^{-1}$ 可以表示为若干个点 $(a_i, i)$，即交换 $xy$ 坐标 对于矩阵 $a$ 我们把它表示为若干个三维的点 $(i, j, a_{i, j})$I 操作对应交换 $yz$ 坐标C 操作对应交换 $xz$ 坐标 剩下的操作也很好办U 操作对应所有 $x$ 坐标-1D 操作对应所有 $x$ 坐标+1L 操作对应所有 $y$ 坐标-1R 操作对应所有 $y$ 坐标+1 维护各个坐标对应的初始时的坐标和各个坐标的变化量即可 总时间复杂度为 $\\Theta(n^2+m)$ 代码 codeforces submission 142751178","link":"/2022/02/02/cf1458c/"},{"title":"CF587F Duff is Mad","text":"题意给定 $n$ 个字符串 $S_{1…n}$.定义 $\\text{occur}(t, s)$ 为 字符串 $t$ 在字符串 $s$ 中的出现次数. 有 $q$ 次询问，每次给出 $l$，$r$ 和 $k$，输出 $\\sum\\limits_{l\\le i\\le r}\\text{occur}(s_i, s_k)$. $n,k,\\sum |s_i|\\le 10^5$ 题解我们对所有串建立fail树 令 $p_{i,j}$ 表示串 $s_i$ 的前 $j$ 个字符在AC自动机上对应点的编号，$end_{i}$ 表示串 $s_i$ 在AC自动机上对应点的编号$s_i$ 在 $s_k$ 中出现就代表 $s_i$ 是 $s_k$ 某个前缀的后缀，因此有 \\sum_{l\\le i\\le r}\\text{occur}(s_i, s_k)=\\sum_{l\\le i\\le r}\\sum_{1\\le j\\le \\text{len}_k}\\text{isanc}(end_{i}, p_{k, j})其中 $\\text{isanc}(x, y)$ 表示在fail树上 $x$ 是否为 $y$ 的祖先 看到 $\\sum |s_i|\\le 10^5$ 这条限制，容易想到对于 $|s_k|$ 根号分治 令 $M=\\sum |s_i|$ $|s_k|&lt;=T$ 容易想到一种做法，$\\forall l\\le i\\le r$，对所有以 $end_i$ 为根的子树的所有点加1，然后查询所有 $p_{k,i}$ 点上的值之和 把每个询问差分为成 $[1, l-1]$ 和 $[1, r]$ 两个区间，然后离线下来按右端点排序，维护区间修改单点查询 树状数组可以做到 $\\mathcal{O}(qT\\log M+n\\log M)$，当然更快的做法是分块的 $\\mathcal{O}(qT+n\\sqrt{M})$ $|s_k|&gt;T$ 满足这个条件的 $k$ 数量是 $\\mathcal{O}(\\frac{M}{T})$ 级别的，因此我们考虑对所有的 $k$ 预处理 考虑另一种做法，把所有 $p_{k,i}$ 标上1，然后查询 $\\forall l\\le i\\le r$，$end_i$ 子树和之和 预处理时我们对 $end_i$ 的子树和做前缀和，询问的差分即可 $\\mathcal{O}(q+\\frac{M}{T}\\times n)$ 选择一个合适的 $T$，我们视 $n$，$M$ 和 $q$ 为同阶，$T$ 取 $\\sqrt{M}$ 即可复杂度可以简单地认为是 $\\mathcal{O}(n\\sqrt{M})$ 代码 codeforces submission 144319232","link":"/2022/01/28/cf587f/"},{"title":"CF717A Festival Organization","text":"题意一个合法的串定义为：长度在 $[l, r]$ 之间，且只含 $0,1$，并且不存在连续 $2$ 个或更多的 $0$.现在要选出 $k$ 个长度相同的不同的合法的串，问有几种选法，答案模 $10^9+7$. $1\\le l\\le r\\le10^{18}, 1\\le k\\le200$. 题解设 $F_{i,j}$ 表示长度为 $i$, 以 $j$ 结尾的合法串个数.有 \\left\\{ \\begin{array}{**lr**} F_{i,0}=F_{i-1,1} & \\\\ F_{i,1}=F_{i-1,0}+F_{i-1,1} & \\end{array} \\right.即 \\left\\{ \\begin{array}{**lr**} F_{i,0}=\\text{Fib}_{i} & \\\\ F_{i,1}=\\text{Fib}_{i+1} & \\end{array} \\right.所以答案 \\text{Ans}=\\sum\\limits_{l+2\\le i\\le r+2}\\begin{pmatrix}\\text{Fib}_i\\\\k\\end{pmatrix} \\begin{align*} \\text{Ans} =&\\sum_{l+2\\leq i\\leq r+2} \\begin{pmatrix}{\\text{Fib}_i}\\\\k\\end{pmatrix}\\\\ =&\\frac{1}{k!}\\sum_{l+2\\le i\\le r+2} {\\text{Fib}_i}^{\\underline{k}}\\\\ =&\\frac{1}{k!}\\sum_{l+2\\le i\\le r+2}\\sum_{1\\le j\\le k}(-1)^{k-j}\\begin{bmatrix}k\\\\ j \\end{bmatrix}{\\text{Fib}_i}^j\\\\ =&\\frac{1}{k!}\\sum_{1\\le i\\le k}(-1)^{k-i}\\begin{bmatrix}k\\\\ i \\end{bmatrix}\\sum_{l+2\\le j\\le r+2}{\\text{Fib}_j}^i \\end{align*}考虑带入斐波那契数的通项，令 $A=\\frac{1+\\sqrt{5}}{2}, B=\\frac{1-\\sqrt{5}}{2}$ \\begin{align*} \\text{Ans} =&\\frac{1}{k!}\\sum_{1\\le i\\le k}(-1)^{k-i}\\begin{bmatrix}k\\\\ i \\end{bmatrix}\\sum_{l+2\\le j\\le r+2}[{\\frac{1}{\\sqrt{5}}(A^j-B^j)}]^i\\\\ =&\\frac{1}{k!}\\sum_{1\\le i\\le k}(-1)^{k-i}\\begin{bmatrix}k\\\\ i \\end{bmatrix}(\\frac{1}{\\sqrt{5}})^i\\sum_{l+2\\le j\\le r+2}\\sum_{0\\le p\\le i}\\begin{pmatrix}i\\\\p\\end{pmatrix}(-1)^p(A^{i-p}B^p)^j\\\\ =&\\frac{1}{k!}\\sum_{1\\le i\\le k}(-1)^{k-i}\\begin{bmatrix}k\\\\ i \\end{bmatrix}(\\frac{1}{\\sqrt{5}})^i\\sum_{0\\le j\\le i}\\begin{pmatrix}i\\\\j\\end{pmatrix}(-1)^j\\sum_{l+2\\le p\\le r+2}(A^{i-j}B^j)^p \\end{align*}等比数列求和快速计算式子后面部分$\\Theta(k^2\\times(\\log l+\\log r))$ 细节本题涉及对 $\\sqrt{5}$ 的计算，然而在模 $10^9+7$ 意义下 $5$ 没有二次剩余，扩域维护即可 代码 codeforces submission 137205589","link":"/2022/01/26/cf717a/"},{"title":"CF802O April Fools&#39; Problem (hard)","text":"题意有 $n$ 道题，第 $i$ 天可以花费 $a_i$ 准备一道题，花费 $b_i$ 打印一道题，每天最多准备一道题，打印一道题，准备的题可以留到以后打印，求打印 $k$ 道题的最小花费. $1\\le k\\le n\\le 5\\times10^5$ 题解显然可以费用流解决，建图如下. 考虑优化费用流 引理 初始不含负圈的图在费用流的增广过程中不会出现负圈 根据引理得，每次增广的增广路都是一条形如 $S\\rightarrow X\\rightarrow Y\\rightarrow T’\\rightarrow T$ 的路径，一共增广 $k$ 次. 设 $f_i$ 表示在残流网络上 $i+1$ 点向 $i$ 的流量，则一条增广路合法当且仅当 $S\\rightarrow X,Y\\rightarrow T’$ 这两条边有流量且满足下列两个条件之一： $X\\le Y$ $X&gt;Y\\land \\min_{Y\\le i&lt;X}f_i&gt;0$ 我们尝试用线段树来模拟这一过程，对于每一个区间 $[l, r]$，维护 $a$ 的最小值计为 $ma$，$b$ 的最小值计为 $mb$，从 $x$ 到 $l$ 有流量的最小 $a_x$ 计为 $fa$，从 $r+1$ 到 $x$ 有流量的最小 $b_x$ 计为 $fb$，从左到右的最小费用流计为 $f1$，从右到左的最小费用流计为 $f2$，从 $r+1$ 到 $l$ 的流量计为 $f$ 每找到一条增广路，在线段树上更新流量并把 $a_X,b_Y$ 赋值 $\\text{Infinity}$ 以标记 $S\\rightarrow X,Y\\rightarrow T’$ 这两条边没有流量 这时候我们发现这个做法是不可行的，应为我们没法对流量快速地区间修改 发现 $f_n$ 的值总是 $0$，我们将 $fa$，$fb$ 和 $f2$ 的定义修改为在整个区间每条边的流量都减去 $f$ 时原定义的值，这样一来区间 $[1, n]$ (也就是我们需要查询的区间) 的值是符合原定义的，二来区间修改时我们只需要更新流量，每次增广的时间复杂度可以做到 $\\Theta(\\log n)$ 总时间复杂度为 $\\Theta(k\\log n)$ 代码 codeforces submission 143973639","link":"/2022/01/26/cf802o/"},{"title":"CF819E Mister B and Flight to the Moon","text":"题意有一个 $n$ 个点的完全图，构造一种方案，用若干个三元环和四元环覆盖该图，使每条边被覆盖两次 $3\\le n\\le 300$ 题解考虑跨度为2的递归构造，即先构造出 $n-2$ 的方案，在以此为基础构造 $n$ 的方案也就是每次递归构造一个这样的图 (左侧的节点可以任意多个，这里仅作示意) 令左侧节点分别为 $1…n-2$，右侧节点为 $n-1$ 和 $n$，可以采取如下构造方案 $\\forall 1\\le i&lt;n-2, (i, n-1, i+1, n)$ $(1, n-1, n),(n-2, n-1, n)$ 演示动画，黑色边为没有覆盖，蓝色边为覆盖1次，红色边为覆盖2次 递归的边界是 $n=3$ 和 $n=4$ 的情况，都十分容易构造 代码 codeforces submission 145084633","link":"/2022/02/04/cf819e/"},{"title":"CF997D Cycles in product","text":"题意给你大小为 $n_1, n_2$​的两棵树 $T_1, T_2$​，构造一张新图，该图中每一个点的编号为 $(u,v)$。如果在 $T_1$ ​中， $u_1$ ​和$u_2$ ​之间有边，那么在该图上，对于任意 $1\\le v\\le n_2$，$(u_1, v)$ 和 $(u_2, v)$ 之间有边。同样，如果在 $T_2$ ​中，$v_1$ ​和$v_2$​之间有边，那么在图上，对于任意 $1\\le u\\le n_1$，$(u, v_1)$ 和 $(u, v_2)$ 之间有边.求这个图上长度为 $K$ 的环有多少个，环可以不为简单环，起始点或方向不同的环视为不同的环. $n_1, n_2\\le 4000, K\\le 75$，答案对 $998244353$ 取模. 题解$T_1$ 上一个长度为 $K_1$ 的环和 $T_2$ 上一个长度为 $K_2$ 的环以不同方式组合对应图上 $\\begin{pmatrix}K_1+K_2\\\\k_1\\end{pmatrix}$ 个环即答案为 $\\sum\\limits_{0\\le i\\le K}F1_i\\times F2_{K-i}\\times\\begin{pmatrix}K\\\\i\\end{pmatrix}$，其中 $F1_i$ 表示 $T_1$ 上长度为 $i$ 的环的个数，$F2_i$ 表示 $T_2$ 上长度为 $i$ 的环的个数 我们把每个点作为起始点分别计算，考虑到树上所有的环长度均为偶数，令 $f_{u, k}$ 表示以 $u$ 为起始点，长度为 $2\\times k$ 的环的个数，有 $F_{2\\times k}=\\sum\\limits_u f_{u, k}$由于从父亲节点往儿子节点转移十分困难，不妨对于每个点只考虑在其子树中的环然后换根DP考虑转移 f_{u,k}=\\sum_{0\\le t","link":"/2022/01/26/cf997d/"},{"title":"LOJ6241 性能优化","text":"题意求 T = \\sum_{1\\le i\\le n}\\sum_{1\\le j\\le\\lfloor \\frac{n}{i} \\rfloor}\\sum_{1\\le k\\le j}[\\gcd(j,k)=1]多组数据$n\\le 10^{10^6}$ 题解T = \\sum_{1\\le i\\le n}\\sum_{1\\le j\\le\\lfloor \\frac{n}{i} \\rfloor}\\varphi(j)令 \\text{S}(n) = \\sum_{1\\le i\\le n}\\varphi(i)则有 \\begin{align*} T &= \\sum_{1\\le i\\le n}\\text{S}(\\lfloor \\frac{n}{i} \\rfloor) \\\\ &= \\text{S}(n) + \\sum_{2\\le i\\le n}\\text{S}(\\lfloor \\frac{n}{i} \\rfloor) \\\\ \\end{align*}根据杜教筛，由 $\\varphi*\\text{I}=\\text{Id}$，有 \\text{I}(1)\\times \\text{S}(n)=\\sum_{1\\le i\\le n}\\text{Id}(i)-\\sum_{2\\le i\\le n}\\text{S}(\\lfloor\\frac{n}{i}\\rfloor)\\times \\text{I}(i)即 \\text{S}(n)=\\frac{n(n+1)}{2}-\\sum_{2\\le i\\le n}\\text{S}(\\lfloor\\frac{n}{i}\\rfloor)带回原式得 \\begin{align*} T=&\\frac{n(n+1)}{2}-\\sum_{2\\le i\\le n}\\text{S}(\\lfloor\\frac{n}{i}\\rfloor) + \\sum_{2\\le i\\le n}\\text{S}(\\lfloor \\frac{n}{i} \\rfloor)\\\\ =&\\frac{n(n+1)}{2} \\end{align*}","link":"/2021/01/15/loj6241/"},{"title":"LUOGU P4119 Ynoi2018 未来日记","text":"题意有一个长度为 $n$ 的序列，共 $m$ 次操作： 1 l r x y，把区间 $[l, r]$ 内所有 $x$ 变成 $y$； 2 l r k，查询区间 $[l, r]$ 内第 $k$ 小值. $1\\le n, m\\le 10^5$，任何时刻 $1\\le a_i\\le 10^5$ 题解对于这种复杂的修改操作，我们直接考虑分块 对序列和值域同时分块，令 $sum_{i, v}$ 表示前 $i$ 块内值 $v$ 的个数，$blsum_{i, j}$ 表示序列前 $i$ 块内值在值域第 $j$ 块内的个数 考虑查询，对于散块我们每次查询构造 $sctsum_{v}$ 表示在散块中值为 $v$ 的个数，$sctblsum_{i}$ 表示散块中值在值域第 $i$ 块内的个数 查询时我们对整块差分再加上散块的贡献，即可 $\\Theta(1)$ 地查询区间 $[l, r]$ 内值为 $v$ 的个数和区间内值在值域第 $i$ 块中的个数 先枚举 $k$ 小值在值域中的哪一块，再枚举 $k$ 小值是该块中的哪一个值，一次查询的时间复杂度为 $\\Theta(\\sqrt{n})$ 考虑修改，对于散块直接暴力修改即可 对于每个整块独立地给块内每一个值一个标号 $id$，颜色相同的有相同的标号，还需要维护值对标号的映射 $rep$ 和值对标号的映射 $col$ 把 $x$ 变成 $y$ 时的两种情况： 块内没有 $y$将 $col_{rep_x}$ 设为 $y$，将 $rep_y$ 设为原来的 $rep_x$，将 $rep_x$ 清空 块内有 $y$不太好处理，直接像对散块一样暴力修改考虑这样做的时间复杂度暴力修改的次数不多于所有块内不同值个数的和，一开始有 $\\mathcal{O}(n)$ 个，每修改一次整块不会增加，只有散块可能增加1，所以总共暴力修改 $\\mathcal{O}(n+m)$ 次，总的暴力修改复杂度即为 $\\mathcal{O}((n+m)\\sqrt{n})$ 最后是如何在散块操作前 “reset” 这一块对于每个值用标号映射得到新的值，也就是将每个 $a_i$ 设为 $col_{id_i}$ 总的时间复杂度为 $\\mathcal{O}((n+m)\\sqrt{n})$ 代码P4119.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000, maxvs = 316;const int maxs = 360, maxc = 278;int cnt;int a[maxn + 5];int lp[maxc + 5], rp[maxvs + 5];int bl[maxn + 5];int vlp[maxvs + 5];int vbl[maxn + 5];int sum[maxc + 5][maxn + 5];int blsum[maxc + 5][maxvs + 5];int rep[maxc + 5][maxn + 5];int col[maxc + 5][maxs + 5];int id[maxn + 5];int ccnt[maxc + 5];void buildUnion(int bid) { for (int i = 1; i &lt;= ccnt[bid]; i++) rep[bid][col[bid][i]] = 0; ccnt[bid] = 0; for (int i = lp[bid]; i &lt;= rp[bid]; i++) { if (rep[bid][a[i]] == 0) { rep[bid][a[i]] = ++ccnt[bid]; col[bid][ccnt[bid]] = a[i]; } id[i] = rep[bid][a[i]]; }}void reset(int bid) { for (int i = lp[bid]; i &lt;= rp[bid]; i++) a[i] = col[bid][id[i]];}void build(int n) { int siz = min(n, int(sqrt(1.3 * n))); cnt = ceil(1. * n / siz); for (int i = 1; i &lt;= n; i++) bl[i] = (i - 1) / siz + 1; for (int i = 1; i &lt;= cnt; i++) { lp[i] = (i - 1) * siz + 1; rp[i] = min(n, i * siz); } for (int i = 1; i &lt;= maxn; i++) vbl[i] = (i - 1) / maxvs + 1; for (int i = 1; i &lt;= maxvs + 1; i++) vlp[i] = (i - 1) * maxvs + 1; for (int i = 1; i &lt;= cnt; i++) { for (int j = 1; j &lt;= maxn; j++) sum[i][j] = sum[i - 1][j]; for (int j = 1; j &lt;= maxvs + 1; j++) blsum[i][j] = blsum[i - 1][j]; for (int j = lp[i]; j &lt;= rp[i]; j++) { sum[i][a[j]]++; blsum[i][vbl[a[j]]]++; } buildUnion(i); }}int tmp[maxn + 5], bltmp[maxvs + 5];void add(int l, int r, int delta) { for (int i = l; i &lt;= r; i++) { tmp[a[i]] += delta; bltmp[vbl[a[i]]] += delta; }}int query(int l, int r, int k) { int lb = bl[l], rb = bl[r]; int res; if (lb == rb) { reset(lb); copy(a + l, a + r + 1, tmp + l); nth_element(tmp + l, tmp + l + k - 1, tmp + r + 1); res = tmp[l + k - 1]; fill(tmp + l, tmp + r + 1, 0); } else { reset(lb); reset(rb); add(l, rp[lb], 1); add(lp[rb], r, 1); int i = 1, delta; for (; k - (delta = bltmp[i] + blsum[rb - 1][i] - blsum[lb][i]) &gt; 0; i++) k -= delta; int j = vlp[i]; for (; k - (delta = tmp[j] + sum[rb - 1][j] - sum[lb][j]) &gt; 0; j++) k -= delta; res = j; add(l, rp[lb], -1); add(lp[rb], r, -1); } return res;}void change(int l, int r, int x, int y, int bid) { int chcnt = 0; for (int i = l; i &lt;= r; i++) { if (a[i] == x) { a[i] = y; chcnt++; } } sum[bid][x] -= chcnt; sum[bid][y] += chcnt; blsum[bid][vbl[x]] -= chcnt; blsum[bid][vbl[y]] += chcnt;}void changeBlock(int l, int r, int x, int y, int bid) { reset(bid); change(l, r, x, y, bid); buildUnion(bid);}void modify(int l, int r, int x, int y) { int lb = bl[l], rb = bl[r]; if (x == y || sum[rb][x] - sum[lb - 1][x] == 0) return; for (int i = cnt; i &gt;= lb; i--) { sum[i][x] -= sum[i - 1][x]; sum[i][y] -= sum[i - 1][y]; blsum[i][vbl[x]] -= blsum[i - 1][vbl[x]]; blsum[i][vbl[y]] -= blsum[i - 1][vbl[y]]; } if (lb == rb) changeBlock(l, r, x, y, lb); else { changeBlock(l, rp[lb], x, y, lb); changeBlock(lp[rb], r, x, y, rb); for (int i = lb + 1; i &lt; rb; i++) { if (sum[i][x] == 0) continue; if (sum[i][y] == 0) { col[i][rep[i][x]] = y; swap(rep[i][y], rep[i][x]); blsum[i][vbl[y]] += sum[i][x]; blsum[i][vbl[x]] -= sum[i][x]; sum[i][y] = sum[i][x]; sum[i][x] = 0; } else changeBlock(lp[i], rp[i], x, y, i); } } for (int i = lb; i &lt;= cnt; i++) { sum[i][x] += sum[i - 1][x]; sum[i][y] += sum[i - 1][y]; blsum[i][vbl[x]] += blsum[i - 1][vbl[x]]; blsum[i][vbl[y]] += blsum[i - 1][vbl[y]]; }}int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); build(n); for (int i = 1; i &lt;= m; i++) { int op, l, r; scanf(&quot;%d%d%d&quot;, &amp;op, &amp;l, &amp;r); if (op == 1) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); modify(l, r, x, y); } else { int k; scanf(&quot;%d&quot;, &amp;k); printf(&quot;%d\\n&quot;, query(l, r, k)); } }}","link":"/2022/02/01/luogu4119/"},{"title":"UOJ435 Simple Tree","text":"题意有一棵有根树，根为 $1$，点有点权.现在有 $m$ 次操作，操作有3种： 1 x y w，将 $x$ 到 $y$ 的路径上的点点权加上 $w$ (其中 $w=\\pm 1$)； 2 x y，询问在 $x$ 到 $y$ 的路径上有多少个点点权 $&gt;0$； 3 x，询问在 $x$ 的子树里的点有多少个点点权 $&gt;0$. 强制在线，$n,m\\le 10^5,-10^9\\le\\text{点权}\\le10^9$ 题解先考虑序列上的做法问题比较复杂，我们用分块来处理 我们把每一块内部预先排好序，维护在排好序的块内下标最小的大于零点的下标 $pts$ 以及对于块中每个数第一个严格大于和小于该数的位置 $nxt$ 和 $lst$ 查询的时候，对于整块，用右端点减去 $pts$ 即可得到答案对于散块暴力统计 修改的时候，对于整块，我们修改零点，然后尝试让 $pts$ 往 $nxt$ 或 $lst$ 跳对于散块，暴力修改并归并排序 把序列问题放在树上，一个显然的想法是树链剖分，$\\mathcal{O}(n\\log n+q\\sqrt{n}\\log{n})$，不足以通过此题 其实在树链剖分的情况下 $\\sqrt{n}$ 的块长不是最优的每次链的询问和修改，涉及的整块是 $\\mathcal{O}(\\sqrt{n})$ 级别的，然而涉及的散块元素个数是 $\\mathcal{O}(\\sqrt{n}\\log{n})$ 级别的，因此块长 $\\sqrt{n\\log n}$ 时取到最优复杂度 $\\mathcal{O}(n\\log n+q\\sqrt{n\\log n})$ 考虑使用一个分块上树通用的trick，对每条链单独分块下面证明链操作的时间复杂度是 $\\mathcal{O}(\\sqrt{n})$ 考虑一条竖直的 (即以一个点与其祖先为顶点) 链，因为任意一条链都可以由两条这样的链组成设这条链从上到下依次经过的重链分别为 $lnk_0, lnk_1, …, lnk_k$由树链剖分的性质，有 \\text{len}(lnk_i)\\le\\text{subtreeSize}(\\text{top}(lnk_i))\\le\\frac{n}{2^i}其中 $\\text{top}(x)$ 表示链 $x$ 的链顶，$\\text{len}(x)$ 表示 $x$ 的链长，$\\text{subtreeSize}(u)$ 表示以 $u$ 为根的子树的大小 \\begin{align*} T(n)&=\\sum_{0\\le i\\le k}\\sqrt{\\text{len}(lnk_i)}\\\\ &\\le\\sum_{0\\le i\\le k}\\sqrt{\\frac{n}{2^i}}\\\\ &=\\sqrt{n}\\sum_{0\\le i\\le k}\\frac{1}{\\sqrt{2}}^i\\\\ &=\\Theta(\\sqrt{n}) \\end{align*}即复杂度为 $\\mathcal{O}(\\sqrt{n})$ 下面考虑子树查询 我们把每条重链按链顶dfn序排序，发现每棵子树都是由一条重链的一部分和排序后连续的完整重链构成修改时，对于 $\\mathcal{O}(\\log n)$ 条被修改的重链，在树状数组上更新答案子树询问时，区间查询即可 总复杂度为 $\\mathcal{O}(n\\log n+q\\sqrt{n}+q\\log^2 n)$ 细节散块常数大，调一调参跑得快 代码uoj435.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000, maxs = 200;int n, q, T;int val[maxn + 5];vector&lt;int&gt; g[maxn + 5];int stamp;int dep[maxn + 5];int fa[maxn + 5];int heavy_son[maxn + 5];int siz[maxn + 5];int tp[maxn + 5], bt[maxn + 5];int id[maxn + 5];int lnk[maxn + 5];int lcnt;int lid[maxn + 5];int minl[maxn + 5], maxl[maxn + 5];void dfs1(int u, int f) { fa[u] = f; dep[u] = dep[f] + 1; siz[u] = 1; for (size_t i = 0; i &lt; g[u].size(); i++) { int v = g[u][i]; if (v == f) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[heavy_son[u]]) heavy_son[u] = v; }}void dfs2(int u, int f, int top) { id[u] = ++stamp; lnk[u] = top; if (u == top) tp[++lcnt] = id[u]; if (heavy_son[u] == 0) bt[lcnt] = id[u]; lid[u] = lcnt; minl[u] = lcnt + 1; if (heavy_son[u]) dfs2(heavy_son[u], u, top); for (size_t i = 0; i &lt; g[u].size(); i++) { int v = g[u][i]; if (v == f || v == heavy_son[u]) continue; dfs2(v, u, v); } maxl[u] = lcnt;}inline int lowbit(int x) { return x &amp; (-x);}struct fenwic { int t[maxn + 5]; void modify(int x, int y) { while (x &lt;= lcnt) { t[x] += y; x += lowbit(x); } } int query_(int x) const { int res = 0; while (x &gt; 0) { res += t[x]; x -= lowbit(x); } return res; } int query(int l, int r) const { return query_(r) - query_(l - 1); }} bit;struct block { int cnt; int tot[maxn + 5]; int a[maxn + 5]; int blg[maxn + 5]; int zero[maxn + 5]; int lp[maxn + 5], rp[maxn + 5], pts[maxn + 5]; pair&lt;int, int&gt; tmp1[maxs + 5], tmp2[maxs + 5]; pair&lt;int, int&gt; sorted[maxn + 5]; int nxt[maxn + 5], lst[maxn + 5], lpts[maxn + 5]; void resize(int arr[], int l, int r, int lk) { int len = r - l + 1; int bsiz = ceil(sqrt(.12 * len)); int bcnt = ceil(1. * len / bsiz); for (int i = l; i &lt;= r; i++) { a[i] = arr[i]; sorted[i] = pair&lt;int, int&gt;(arr[i], i); } for (int i = cnt + 1; i &lt;= cnt + bcnt; i++) { lp[i] = l + (i - cnt - 1) * bsiz; rp[i] = min(r, l + (i - cnt) * bsiz - 1); for (int j = lp[i]; j &lt;= rp[i]; j++) blg[j] = i; sort(sorted + lp[i], sorted + rp[i] + 1); calcNxtLst(i); tot[lk] += rp[i] - pts[i] + 1; } cnt += bcnt; } void calcNxtLst(int bid) { for (int i = rp[bid], j = rp[bid] + 1; i &gt;= lp[bid]; i--) { while (i &gt; lp[bid] &amp;&amp; sorted[i].first == sorted[i - 1].first) i--; nxt[i] = j; if (j &lt;= rp[bid]) lst[j] = i; else lpts[bid] = i; j = i; } lst[lp[bid]] = lp[bid]; pts[bid] = rp[bid] + 1; for (int i = lp[bid]; i &lt;= rp[bid]; i++) { if (sorted[i].first &gt; zero[bid]) { pts[bid] = i; break; } } } void mergeSort(int bid, int l, int r, int delta, int lk) { tot[lk] += pts[bid]; for (int i = l; i &lt;= r; i++) a[i] += delta; int cnt1 = 0, cnt2 = 0; for (int i = lp[bid]; i &lt;= rp[bid]; i++) { if (sorted[i].second &gt;= l &amp;&amp; sorted[i].second &lt;= r) tmp1[++cnt1] = pair&lt;int, int&gt;(sorted[i].first + delta, sorted[i].second); else tmp2[++cnt2] = sorted[i]; } merge(tmp1 + 1, tmp1 + cnt1 + 1, tmp2 + 1, tmp2 + cnt2 + 1, sorted + lp[bid]); calcNxtLst(bid); tot[lk] -= pts[bid]; } void modify(int l, int r, int delta, int lk) { int lb = blg[l], rb = blg[r]; if (lb == rb) mergeSort(lb, l, r, delta, lk); else { mergeSort(lb, l, rp[lb], delta, lk); mergeSort(rb, lp[rb], r, delta, lk); for (int i = lb + 1; i &lt; rb; i++) { tot[lk] += pts[i]; zero[i] -= delta; if (pts[i] &gt; rp[i]) { if (sorted[lpts[i]].first &gt; zero[i]) pts[i] = lpts[i]; } else { if (delta == 1) { if (sorted[lst[pts[i]]].first &gt; zero[i]) pts[i] = lst[pts[i]]; } else if (sorted[pts[i]].first &lt;= zero[i]) pts[i] = nxt[pts[i]]; } tot[lk] -= pts[i]; } } } int query(int l, int r) const { int res = 0; int lb = blg[l], rb = blg[r]; if (lb == rb) { for (int i = l; i &lt;= r; i++) if (a[i] &gt; zero[lb]) res++; } else { for (int i = l; i &lt;= rp[lb]; i++) if (a[i] &gt; zero[lb]) res++; for (int i = lp[rb]; i &lt;= r; i++) if (a[i] &gt; zero[rb]) res++; for (int i = lb + 1; i &lt; rb; i++) res += rp[i] - pts[i] + 1; } return res; }} bl;int queryLnk(int x, int y) { int res = 0; while (lnk[x] != lnk[y]) { if (dep[lnk[x]] &lt; dep[lnk[y]]) swap(x, y); res += bl.query(tp[lid[x]], id[x]); x = fa[lnk[x]]; } if (dep[y] &lt; dep[x]) swap(x, y); res += bl.query(id[x], id[y]); return res;}int querySubtree(int x) { return bl.query(id[x], bt[lid[x]]) + bit.query(minl[x], maxl[x]);}void modifyLnk(int x, int y, int delta) { while (lnk[x] != lnk[y]) { if (dep[lnk[x]] &lt; dep[lnk[y]]) swap(x, y); int ori = bl.tot[lid[x]]; bl.modify(tp[lid[x]], id[x], delta, lid[x]); bit.modify(lid[x], bl.tot[lid[x]] - ori); x = fa[lnk[x]]; } if (dep[y] &lt; dep[x]) swap(x, y); int ori = bl.tot[lid[x]]; bl.modify(id[x], id[y], delta, lid[x]); bit.modify(lid[x], bl.tot[lid[x]] - ori);}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;q, &amp;T); for (int i = 1; i &lt; n; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } dfs1(1, 0); dfs2(1, 0, 1); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;val[id[i]]); for (int i = 1; i &lt;= lcnt; i++) { bl.resize(val, tp[i], bt[i], i); bit.modify(i, bl.tot[i]); } int lstans = 0; for (int i = 1; i &lt;= q; i++) { int op, x, y, w; scanf(&quot;%d%d&quot;, &amp;op, &amp;x); if (T == 1) x ^= lstans; if (op == 1) { scanf(&quot;%d%d&quot;, &amp;y, &amp;w); if (T == 1) y ^= lstans; modifyLnk(x, y, w); } else if (op == 2) { scanf(&quot;%d&quot;, &amp;y); if (T == 1) y ^= lstans; printf(&quot;%d\\n&quot;, lstans = queryLnk(x, y)); } else printf(&quot;%d\\n&quot;, lstans = querySubtree(x)); }}","link":"/2022/01/30/uoj435/"},{"title":"UOJ450 复读机","text":"题意$k$ 种球，每种个数必须是 $d$ 的倍数，共 $n$ 个，求排成一行的方案数. $n\\le 10^9, k\\le 5\\times10^5, d\\le 3$，答案对 $19491001$ 取模. 题解 \\begin{align*} \\text{Ans}&=n!\\sum_{i_1 \\ge 0,d\\mid i_1}\\frac{1}{i_1!}\\sum_{0\\le i_2,d\\mid i_2}\\frac{1}{i_2!}\\cdots\\sum_{0\\le i_k,d\\mid i_k}\\frac{1}{i_k!}\\\\ &=[x^n]n!(\\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!})^k\\\\ \\end{align*} \\begin{align*} \\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!}&=\\sum_{i\\ge 0}\\frac{x^i}{i!}\\frac{1}{d}\\sum_{0\\le j < d}{\\omega_d^j}^i& \\text{单位根反演}\\\\ &=\\frac{1}{d}\\sum_{0\\le j < d}\\sum_{i\\ge 0}\\frac{(x\\omega_d^j)^i}{i!}\\\\ &=\\frac{1}{d}\\sum_{0\\le j < d}e^{x\\omega_d^j}& \\text{泰勒展开}\\\\ \\end{align*}$d=2$： \\begin{align*} \\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!}&=\\frac{1}{d}\\sum_{0\\le j < d}e^{x\\omega_d^j}\\\\ &=\\frac{e^x+e^{-x}}{2}\\\\ (\\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!})^k&=n!(\\frac{e^x+e^{-x}}{2})^k\\\\ &=\\frac{1}{2^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}e^{ix}e^{-x(k-i)} & \\text{二项式定理}\\\\ &=\\frac{1}{2^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}e^{2ix-kx}\\\\ \\text{Ans}&=[x^n]n!(\\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!})^k\\\\ &=\\frac{n!}{2^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}[x^n]e^{2ix-kx}\\\\ &=\\frac{n!}{2^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\frac{(2i-k)^n}{n!} & \\text{泰勒展开}\\\\ &=\\frac{1}{2^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}(2i-k)^n \\end{align*}$d=3$： \\begin{align*} \\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!}&=\\frac{1}{d}\\sum_{0\\le j < d}e^{x\\omega_d^j}\\\\ &=\\frac{e^x+e^{\\omega_3x}+e^{\\omega_3^2x}}{3}\\\\ (\\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!})^k&=n!(\\frac{e^x+e^{\\omega_3x}+e^{\\omega_3^2x}}{3})^k\\\\ &=\\frac{1}{3^k}\\sum_{0\\le i\\le k}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\sum_{0\\le j\\le k-i}\\begin{pmatrix}k-i\\\\j\\end{pmatrix}e^{ix}e^{j\\omega_3x}e^{(k-i-j)\\omega_3^2x} & \\text{多项式定理}\\\\ &=\\frac{1}{3^k}\\sum_{0\\le i\\le k}\\sum_{0\\le j\\le k-i}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\begin{pmatrix}k-i\\\\j\\end{pmatrix}e^{ix+j\\omega_3x+k\\omega_3^2x-i\\omega_3^2x-j\\omega_3^2x}\\\\ \\text{Ans}&=[x^n]n!(\\sum_{i\\ge 0,d\\mid i}\\frac{x^i}{i!})^k\\\\ &=\\frac{n!}{3^k}\\sum_{0\\le i\\le k}\\sum_{0\\le j\\le k-i}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\begin{pmatrix}k-i\\\\j\\end{pmatrix}[x^n]e^{ix+j\\omega_3x+k\\omega_3^2x-i\\omega_3^2x-j\\omega_3^2x}\\\\ &=\\frac{n!}{3^k}\\sum_{0\\le i\\le k}\\sum_{0\\le j\\le k-i}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\begin{pmatrix}k-i\\\\j\\end{pmatrix}\\frac{(i+j\\omega_3+k\\omega_3^2-i\\omega_3^2-j\\omega_3^2)^n}{n!} & \\text{泰勒展开}\\\\ &=\\frac{1}{3^k}\\sum_{0\\le i\\le k}\\sum_{0\\le j\\le k-i}\\begin{pmatrix}k\\\\i\\end{pmatrix}\\begin{pmatrix}k-i\\\\j\\end{pmatrix}(i+j\\omega_3+k\\omega_3^2-i\\omega_3^2-j\\omega_3^2)^n \\end{align*}","link":"/2021/10/16/uoj450/"},{"title":"CF1610F Mashtali: a Space Oddysey","text":"题意现在有一个由 $n$ 个节点 $m$ 条边组成的无向图，每条边的边权 $w\\in\\{1, 2\\}$.令 ${d^+}_u$ 表示 $u$ 所有出边的权值和，令 ${d^-}_u$ 表示 $u$ 所有入边的权值和，一个点 $u$ 是好的，当且仅当 $|{d^+}_u-{d^-}_u|=1$给每一条边定向，使得图上好的点最多，输出任意一种方案 $n,m\\le3\\times10^5$ 题解令 $c_{w, u}$ 表示点 $u$ 边权为 $w$ 的边的个数，$s_{w, u}$ 表示点 $u$ 边权为 $w$ 的出边的数量减去边权为 $w$ 的入边的数量 显然答案有上界 $\\sum\\limits_u [c_{1, u}\\bmod 2=1]$，我们尝试达到这个上界 这里考虑经典的欧拉回路的构造方法对两种边权分别考虑，利用欧拉回路的性质，使得 $s_{1, u}$ 和 $s_{2, u}$ 都尽量接近0 建立新图，对于 $(u, v, w)\\in E$，若 $w=1$，则新图上有边 $(u, v)$，否则有边 $(u+n, v+n)$，这些边我们称之为关键边 接下来分两类讨论： $c_{1, u}\\bmod 2=c_{2, u}\\bmod 2=1$我们除了需要保证 $|s_{1, u}|=|s_{2, u}|=1$，还需要 $\\text{sgn}(s_{1, u})\\not=\\text{sgn}(s_{2, u})$为此我们连边 $(u, u+n)$ $c_{1, u}\\bmod 2=1,c_{2, u}\\bmod 2=0$只需保证 $|s_{1, u}|=1,s_{2, u}=0$ 即可，无需额外连边 为了让新图上存在欧拉回路，我们添加一个节点 $S$，与目前度数为奇数的点，也就是满足 $c_{1, u}\\bmod 2=1,c_{2, u}\\bmod 2=0$ 或 $c_{1, u}\\bmod 2=0,c_{2, u}\\bmod 2=1$ 的点连边 最后跑一遍欧拉回路定向，把关键边的方向对应回原图即可 时间复杂度为 $\\Theta(n+m)$ 代码 codeforces submission 145198606","link":"/2022/02/05/cf1610f/"}],"tags":[{"name":"树形DP","slug":"树形DP","link":"/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"除法分块","slug":"除法分块","link":"/tags/%E9%99%A4%E6%B3%95%E5%88%86%E5%9D%97/"},{"name":"根号分治","slug":"根号分治","link":"/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"},{"name":"组合","slug":"组合","link":"/tags/%E7%BB%84%E5%90%88/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"AC自动机","slug":"AC自动机","link":"/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"fail树","slug":"fail树","link":"/tags/fail%E6%A0%91/"},{"name":"斯特林数","slug":"斯特林数","link":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"二项式定理","slug":"二项式定理","link":"/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"多项式","slug":"多项式","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"杜教筛","slug":"杜教筛","link":"/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"name":"单位根反演","slug":"单位根反演","link":"/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"},{"name":"泰勒展开","slug":"泰勒展开","link":"/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/"},{"name":"欧拉回路","slug":"欧拉回路","link":"/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"根号算法","slug":"根号算法","link":"/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","link":"/categories/%E6%A0%91/"},{"name":"图论","slug":"图论","link":"/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"字符串","slug":"字符串","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"分块","slug":"根号算法/分块","link":"/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E5%88%86%E5%9D%97/"},{"name":"构造","slug":"构造","link":"/categories/%E6%9E%84%E9%80%A0/"},{"name":"树形DP","slug":"树/树形DP","link":"/categories/%E6%A0%91/%E6%A0%91%E5%BD%A2DP/"},{"name":"最小生成树","slug":"图论/最小生成树","link":"/categories/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"根号分治","slug":"根号算法/根号分治","link":"/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"},{"name":"AC自动机","slug":"字符串/AC自动机","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"组合","slug":"数学/组合","link":"/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"},{"name":"网络流","slug":"图论/网络流","link":"/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"多项式","slug":"多项式","link":"/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"数论","slug":"数学/数论","link":"/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"},{"name":"树链剖分","slug":"树/树链剖分","link":"/categories/%E6%A0%91/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"数据结构/线段树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"欧拉回路","slug":"图论/欧拉回路","link":"/categories/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"}]}