<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fisher&#39;s blog</title>
  
  <subtitle>OIer</subtitle>
  <link href="https://gzezfisher.top/atom.xml" rel="self"/>
  
  <link href="https://gzezfisher.top/"/>
  <updated>2022-02-19T06:31:33.058Z</updated>
  <id>https://gzezfisher.top/</id>
  
  <author>
    <name>Fisher Cai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CF1610F Mashtali: a Space Oddysey</title>
    <link href="https://gzezfisher.top/2022/02/05/cf1610f/"/>
    <id>https://gzezfisher.top/2022/02/05/cf1610f/</id>
    <published>2022-02-05T09:05:47.000Z</published>
    <updated>2022-02-19T06:31:33.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有一个由 $n$ 个节点 $m$ 条边组成的无向图，每条边的边权 $w\in\{1, 2\}$.<br>令 ${d^+}_u$ 表示 $u$ 所有出边的权值和，令 ${d^-}_u$ 表示 $u$ 所有入边的权值和，一个点 $u$ 是好的，当且仅当 $|{d^+}_u-{d^-}_u|=1$<br>给每一条边定向，使得图上好的点最多，输出任意一种方案</p><p>$n,m\le3\times10^5$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>令 $c_{w, u}$ 表示点 $u$ 边权为 $w$ 的边的个数，$s_{w, u}$ 表示点 $u$ 边权为 $w$ 的出边的数量减去边权为 $w$ 的入边的数量</p><p>答案有上界 $\sum\limits_u [c_{1, u}\bmod 2=1]$，而且这个上界是能够构造达到的</p><p>这里考虑经典的欧拉回路的构造方法<br>对两种边权分别考虑，利用欧拉回路的性质，使得 $s_{1, u}$ 和 $s_{2, u}$ 都尽量接近0</p><p>建立新图，对于原图上一条边 $(u, v, w)$，若 $w=1$，则新图上有边 $(u, v)$，否则有边 $(u+n, v+n)$，这两种边称为关键边</p><p>接下来分两类讨论：</p><ul><li>$c_{1, u}\bmod 2=c_{2, u}\bmod 2=1$<br>除了需要保证 $|s_{1, u}|=|s_{2, u}|=1$，还需要 $\text{sgn}(s_{1, u})\not=\text{sgn}(s_{2, u})$<br>因此连边 $(u, u+n)$</li><li>$c_{1, u}\bmod 2=1,c_{2, u}\bmod 2=0$<br>只需保证 $|s_{1, u}|=1,s_{2, u}=0$，无需额外连边</li></ul><p>为了让新图上存在欧拉回路，再添加一个节点 $S$，与目前度数为奇数的点，也就是满足 $c_{1, u}\bmod 2=1,c_{2, u}\bmod 2=0$ 或 $c_{1, u}\bmod 2=0,c_{2, u}\bmod 2=1$ 的点连边</p><p>最后跑一遍欧拉回路定向，把关键边的方向对应回原图即可</p><p>时间复杂度为 $\Theta(n+m)$</p><p>代码 <a href="https://codeforces.com/contest/1610/submission/145198606">codeforces submission 145198606</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;现在有一个由 $n$ 个节点 $m$ 条边组成的无向图，每条边的边权 $w\in\{1, 2\}$.&lt;br&gt;令 ${d^+}_u$ 表示 $u$ 所有出边的权值和，令 ${d^-}_u$ 表示 $u$ 所有入边的权值和，一个点 $u$ 是好的，当且仅当 $|{d^+}_u-{d^-}_u|=1$&lt;br&gt;给每一条边定向，使得图上好的点最多，输出任意一种方案&lt;/p&gt;
&lt;p&gt;$n,m\le3\times10^5$&lt;br&gt;</summary>
    
    
    
    <category term="图论" scheme="https://gzezfisher.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="欧拉回路" scheme="https://gzezfisher.top/categories/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    
    
    <category term="欧拉回路" scheme="https://gzezfisher.top/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>CF819E Mister B and Flight to the Moon</title>
    <link href="https://gzezfisher.top/2022/02/04/cf819e/"/>
    <id>https://gzezfisher.top/2022/02/04/cf819e/</id>
    <published>2022-02-04T02:43:58.000Z</published>
    <updated>2022-02-05T08:36:47.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个 $n$ 个点的完全图，构造一种方案，用若干个三元环和四元环覆盖该图，使每条边被覆盖两次</p><p>$3\le n\le 300$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑跨度为2的递归构造，即先构造出 $n-2$ 的方案，在以此为基础构造 $n$ 的方案<br>也就是每次递归构造一个这样的图 (左侧的节点可以任意多个，这里仅作示意)</p><p><img src="/img/cf819e/graph.svg" alt="示意图"></p><p>令左侧节点分别为 $1…n-2$，右侧节点为 $n-1$ 和 $n$，可以采取如下构造方案</p><ul><li>$\forall 1\le i&lt;n-2, (i, n-1, i+1, n)$</li><li>$(1, n-1, n),(n-2, n-1, n)$</li></ul><p><a href="/img/cf819e/construct.svg">演示动画</a>，黑色边为没有覆盖，蓝色边为覆盖1次，红色边为覆盖2次</p><p>递归的边界是 $n=3$ 和 $n=4$ 的情况，都十分容易构造</p><p>代码 <a href="https://codeforces.com/contest/819/submission/145084633">codeforces submission 145084633</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;有一个 $n$ 个点的完全图，构造一种方案，用若干个三元环和四元环覆盖该图，使每条边被覆盖两次&lt;/p&gt;
&lt;p&gt;$3\le n\le 300$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="构造" scheme="https://gzezfisher.top/categories/%E6%9E%84%E9%80%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>CF1588F Jumping Through the Array</title>
    <link href="https://gzezfisher.top/2022/02/03/cf1588f/"/>
    <id>https://gzezfisher.top/2022/02/03/cf1588f/</id>
    <published>2022-02-03T06:23:26.000Z</published>
    <updated>2022-02-05T12:54:21.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个长度为 $n$ 的数组 $a$ 和一个长度为 $n$ 的排列 $p$，对于每一个 $i$ 有一条有向边 $(i, p_i)$.<br>有 $q$ 次如下三种操作：</p><ul><li><code>1 l r</code>，询问 $\sum\limits_{l\le i\le r}a_i$</li><li><code>2 v x</code>，将所有从 $v$ 出发能到达的节点的编号在 $a$ 上对应的值加上 $x$</li><li><code>3 x y</code>，交换 $p_x$ 和 $p_y$</li></ul><p>$n,q\le2\times 10^5$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑分块</p><p>显然对序列分块是没有用的，考虑经典的对操作序列分块的做法<br>也就是说，只有在处理完一块时暴力更新 $a$，查询时考虑本块内的修改的贡献，再通过 $a$ 计算其他块的贡献</p><p>由于 $p$ 始终是一个排列，在任一时刻所有边构成的图由若干个环组成</p><p>注意到每次操作3会更改两个点的出边，我们称这样的点为关键点<br>这些关键点将图分为若干部分，每部分由一个关键点和所有不经过其他关键点能到达该关键点的点组成，成为色块，如图 (实心的为关键点)<br>在这一块中任一时刻的图上，这些色块是一个整体，可以放在一起考虑</p><p><img src="/img/cf1588f/graph.svg" alt="示意图"></p><p>由于关键点只有 $\mathcal{O}(\sqrt{n})$ 个，色块也只有 $\mathcal{O}(\sqrt{n})$ 个</p><p>对于操作2从 $v$ 开始遍历色块，在所有能到达的色块上打一个加法标记即可<br>关于色块的遍历，我们每次跳到块中的关键点，然后沿着它的出边到达下一个色块，直到回到了最开始的色块<br>需要特别注意的是，不是所有的点都能被色块包含，为了避免 $v$ 不属于任何色块，我们将所有 $v$ 也设为关键点</p><p>对于操作3直接更改出边即可</p><p>现在考虑操作1<br>对于每一个询问我们将其差分为两个前缀和，也就是一个块内一共询问 $\mathcal{O}(\sqrt{n})$ 个前缀和，称为有意义的前缀和<br>由于一共只有 $\mathcal{O}(\sqrt{n})$ 种颜色和 $\mathcal{O}(\sqrt{n})$ 个有意义的前缀和，可以 $\Theta(n)$ 预处理出在所有有意义的前缀和中每种颜色的点的个数<br>具体方法是从前到后枚举 $n$ 个前缀，维护每种颜色各出现多少次，遇到有意义的前缀就将出现次数记下<br>询问的时候枚举所有颜色，由每种颜色的出现次数乘上该颜色的加法标记即可得到块内的贡献</p><p>最后是 $a$ 数组的重构，每个数加上它所在色块的加法标记即可<br>为了询问方便，对 $a$ 做一次前缀和</p><p>每块预处理的时间复杂度为 $\Theta(n\sqrt{n})$，所有修改与询问的时间复杂度为 $\mathcal{O}(n\sqrt{n})$，因此总时间复杂度为 $\Theta(n\sqrt{n})$</p><p>代码 <a href="https://codeforces.com/contest/1588/submission/144997997">codeforces submission 144997997</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;有一个长度为 $n$ 的数组 $a$ 和一个长度为 $n$ 的排列 $p$，对于每一个 $i$ 有一条有向边 $(i, p_i)$.&lt;br&gt;有 $q$ 次如下三种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 l r&lt;/code&gt;，询问 $\sum\limits_{l\le i\le r}a_i$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 v x&lt;/code&gt;，将所有从 $v$ 出发能到达的节点的编号在 $a$ 上对应的值加上 $x$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3 x y&lt;/code&gt;，交换 $p_x$ 和 $p_y$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$n,q\le2\times 10^5$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="根号算法" scheme="https://gzezfisher.top/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/"/>
    
    <category term="分块" scheme="https://gzezfisher.top/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E5%88%86%E5%9D%97/"/>
    
    
    <category term="分块" scheme="https://gzezfisher.top/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>CF1436F Sum Over Subsets</title>
    <link href="https://gzezfisher.top/2022/02/02/cf1436f/"/>
    <id>https://gzezfisher.top/2022/02/02/cf1436f/</id>
    <published>2022-02-02T08:07:34.000Z</published>
    <updated>2022-02-05T12:19:56.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个可重集 $S$，值为 $i$ 的元素有 $freq_i$ 个<br>有两个集合 $A,B$ 满足</p><ul><li>$B\subset A\subseteq S$</li><li>$|B|=|A|-1$</li><li>$\gcd\limits_{x\in A}x=1$</li></ul><p>称这两个集合的权值 $w(A,B)=\sum\limits_{x\in A}x\sum\limits_{y\in B}y$<br>求所有可能的集合对 $(A, B)$ 的权值之和</p><p>$1\le a_i\le10^5,freq_i\le10^9$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$\gcd_{x\in A}x=1$ 是一个棘手的条件</p><p>考虑令 $f_i$ 表示满足 $\gcd\limits_{x\in A}x=i$ 时的答案，$g_i$ 表示满足 $i\mid\gcd_{x\in A}x$ 时的答案<br>有 $g_i=\sum\limits_{i\mid j}f_j$<br>求出 $g$ 以后，可以莫比乌斯反演得到 $f$<br>即 $f_i=\sum\limits_{j\mid i}\mu(j)\times g_j$</p><p>所以答案 $\text{Ans}=\sum\limits_{1\le i}\mu(i)\times g_i$</p><p>接下来考虑求 $g_i$</p><p>先构造集合 $S’=\{x|x\in S,i\mid x\}$<br>有</p><script type="math/tex; mode=display">\begin{align*}g_i&=\sum_{B\subset A\subseteq S',|B|=|A|-1}w(A,B)\\&=\sum_{B\subset A\subseteq S',|B|=|A|-1}\sum_{x\in A}\sum_{y\in B}x\times y\end{align*}</script><p>我们考虑每一对 $(x\in A, y\in B)$ 对 $g_i$ 的贡献</p><p>称在集合 $A$ 中但不再集合 $B$ 中的元素为特殊元素，在集合 $A$ 和 $B$ 中的为普通元素<br>分两种情况讨论：</p><ul><li>$x, y$ 是同一个元素<br>显然 $x$ 是普通元素<br>那么我们从剩下 $|S’|-1$ 个元素中选出一个特殊元素，再从剩下的 $|S’|-2$ 个元素中任选若干个作为普通元素<br>有 $(|S’|-1)\times 2^{|S’|-2}$ 种方案，产生 $(|S’|-1)\times 2^{|S’|-2}\times x^2$ 的贡献</li><li>$x, y$ 是不同的<strong>元素</strong>，注意是元素不同，不是值不同<br>显然 $y$ 是普通元素<br>若 $x$ 是普通元素，类似的有 $(|S’|-2)\times 2^{|S’|-3}$ 种方案<br>若 $x$ 是特殊元素，在剩下的 $|S’|-2$ 个元素中任选作为普通元素，有 $s^{|S’|-2}$ 种方案<br>共 $(|S’|-2)\times 2^{|S’|-3}+s^{|S’-2|}$ 种方案，产生贡献 $[(|S’|-2)\times 2^{|S’|-3}+s^{|S’|-2}]\times x\times y$</li></ul><p>回到本题，由于 $freq$ 特别大，我们把值相同的元素放在一起考虑<br>相同值 $x$ 之间的贡献有两种</p><ul><li>同元素<br>套用上面同元素的贡献，乘上值为 $x$ 的元素个数即可<br>即有贡献 $(|S’|-1)\times 2^{|S’|-2}\times x^2\times freq_x$</li><li>不同元素<br>套用上面不同元素的贡献<br>即有贡献 $[(|S’|-2)\times 2^{|S’|-3}+s^{|S’|-2}]\times x^2\times freq_x\times (freq_x-1)$</li></ul><p>不同的值 $x, y$ 之间的贡献<br>类似的 $[(|S’|-2)\times 2^{|S’|-3}+s^{|S’|-2}]\times x\times y\times freq_x\times freq_y$</p><p>直接求 $\sum\limits_{x,y\in S’,x\not =y}[(|S’|-2)\times 2^{|S’|-3}+s^{|S’|-2}]\times x\times y\times freq_x\times freq_y$ 显然时间上不能接受</p><p>稍稍转化一下</p><script type="math/tex; mode=display">\begin{align*}&\sum_{x,y\in S',x\not =y}[(|S'|-2)\times 2^{|S'|-3}+s^{|S'|-2}]\times x\times y\times freq_x\times freq_y\\=&[(|S'|-2)\times 2^{|S'|-3}+s^{|S'|-2}]\sum_{x,y\in S',x\not =y}x\times freq_x\times y\times freq_y\\=&[(|S'|-2)\times 2^{|S'|-3}+s^{|S'|-2}][(\sum_{x\in S'}x\times freq_x)^2-\sum_{x\in S'}(x\times freq_x)^2]\end{align*}</script><p>至此我们得到了一个调和级数时间复杂度的算法，即 $\Theta(n\log n)$</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>计算 $|S’|$ 时不要直接模 $998244353$，因为它要放在指数上</p><p>代码 <a href="https://codeforces.com/contest/1436/submission/144913462">codeforces submission 144913462</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给出一个可重集 $S$，值为 $i$ 的元素有 $freq_i$ 个&lt;br&gt;有两个集合 $A,B$ 满足&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$B\subset A\subseteq S$&lt;/li&gt;
&lt;li&gt;$|B|=|A|-1$&lt;/li&gt;
&lt;li&gt;$\gcd\limits_{x\in A}x=1$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;称这两个集合的权值 $w(A,B)=\sum\limits_{x\in A}x\sum\limits_{y\in B}y$&lt;br&gt;求所有可能的集合对 $(A, B)$ 的权值之和&lt;/p&gt;
&lt;p&gt;$1\le a_i\le10^5,freq_i\le10^9$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="组合" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"/>
    
    <category term="数论" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"/>
    
    
    <category term="组合" scheme="https://gzezfisher.top/tags/%E7%BB%84%E5%90%88/"/>
    
    <category term="莫比乌斯反演" scheme="https://gzezfisher.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>CF1458C Latin Square</title>
    <link href="https://gzezfisher.top/2022/02/02/cf1458c/"/>
    <id>https://gzezfisher.top/2022/02/02/cf1458c/</id>
    <published>2022-02-02T00:27:37.000Z</published>
    <updated>2022-02-04T02:46:16.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个 $n\times n$ 的矩阵，每行每列都是一个 $[1, n]$ 的排列，有 $m$ 次操作</p><ul><li><code>U</code> 表示整个矩阵循环下移一格</li><li><code>D</code> 表示整个矩阵循环上移一格</li><li><code>L</code> 表示整个矩阵循环左移一格</li><li><code>R</code> 表示整个矩阵循环右移一格</li><li><code>I</code> 表示把矩阵每一行变为原来排列的逆</li><li><code>R</code> 表示把矩阵每一列变为原来排列的逆</li></ul><p>多组测试数据，$1\le T\le 1000$，$1\le n, m$，$\sum n\le 1000,\sum m\le 10^5$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑排列逆的含义</p><p>一个排列 $a$ 可以表示为若干个点 $(i, a_i)$<br>根根据排列逆的定义，我们可以发现 $a$ 的逆 $a^{-1}$ 可以表示为若干个点 $(a_i, i)$，即交换 $xy$ 坐标</p><p>对于矩阵 $a$ 我们把它表示为若干个三维的点 $(i, j, a_{i, j})$<br><code>I</code> 操作对应交换 $yz$ 坐标<br><code>C</code> 操作对应交换 $xz$ 坐标</p><p>剩下的操作也很好办<br><code>U</code> 操作对应所有 $x$ 坐标-1<br><code>D</code> 操作对应所有 $x$ 坐标+1<br><code>L</code> 操作对应所有 $y$ 坐标-1<br><code>R</code> 操作对应所有 $y$ 坐标+1</p><p>维护各个坐标对应的初始时的坐标和各个坐标的变化量即可</p><p>总时间复杂度为 $\Theta(n^2+m)$</p><p>代码 <a href="https://codeforces.com/contest/1458/submission/142751178">codeforces submission 142751178</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给出一个 $n\times n$ 的矩阵，每行每列都是一个 $[1, n]$ 的排列，有 $m$ 次操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;U&lt;/code&gt; 表示整个矩阵循环下移一格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;D&lt;/code&gt; 表示整个矩阵循环上移一格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L&lt;/code&gt; 表示整个矩阵循环左移一格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 表示整个矩阵循环右移一格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; 表示把矩阵每一行变为原来排列的逆&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 表示把矩阵每一列变为原来排列的逆&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多组测试数据，$1\le T\le 1000$，$1\le n, m$，$\sum n\le 1000,\sum m\le 10^5$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>CF442D Adam and Tree</title>
    <link href="https://gzezfisher.top/2022/02/01/cf442d/"/>
    <id>https://gzezfisher.top/2022/02/01/cf442d/</id>
    <published>2022-02-01T14:09:47.000Z</published>
    <updated>2022-02-05T12:37:00.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>彩色树是边有颜色的有根树，其中每一种颜色的边集构成一条链.<br>定义一棵彩色树的权值为所有节点到根节点路径上不同颜色的数量的最大值.<br>现在有一棵不断变化的树，一开始只有1号点 (根节点)，接下来每个时刻长出一个新点，求每一时刻树的权值</p><p>长出的节点数 $n\le10^5$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先考虑树静止时怎么做</p><p>发现必然存在一种最优方案，其中任意一种颜色的边集构成的链都是竖直的 (即以一个点与其祖先为顶点)，证明是所有其他的最优方案都可以转化为这种方案</p><p><img src="/img/cf442d/tree.svg" alt="示意图"><br>令 $val_u$ 表示点 $u$ 的子树与 $u$ 到父亲的边构成的树的最小权值 (如图，$val_{v_1}$ 为红色树的最小权值，$val_{v_2}$ 为蓝色树的最小权值)<br>发现 $val_u$ 对应的树包含所有 $val_v,v\in\text{son}_u$ 对应的树，再加上 $u$ 到其父亲的边</p><p>考虑 $u$ 到其父亲的边如何选择颜色<br>我们找出 $val_v$ 最大的 $v$ 记为 $maxv_u$，让 $u$ 到其父亲的边继承边 $(u, maxv_u)$ 的颜色，显然这样是最优的<br>即 </p><script type="math/tex; mode=display">val_u=\max\{\max_{v\in\text{son}_u,v\not=maxv_u}val_v+1, val_{maxv_u}\}</script><p>我们记下 $val_v$ 的最大值 $max_u$，非严格次大值 $secmax_u$<br>于是有</p><script type="math/tex; mode=display">val_u=\max\{max_u, secmax_u+1\}</script><p>DP即可，注意答案为 $max_1$</p><p>每次加点，我们从新加的点不断向上更新，这样的时间复杂度是 $\mathcal{O}(n^2)$，不足以通过此题</p><p>考虑做一点小优化<br>我们在向上跳的过程中，如果已经无法更新 $val$，那么再往上跳也无法更新<br>此时停下即可</p><p>下面证明这样做复杂度是 $\mathcal{O}(n\log n)$ 的</p><p>时间复杂度即为更新 $val$ 的次数，即 $T(n)=\sum\limits_{1\le i\le n}val_i$<br>$val_i$ 的上界是 $\log_2 n$<br>我们通过构造来证明，实际上并不需要我们自己构造，因为树链剖分已经帮我们构造好了</p><p>代码 <a href="https://codeforces.com/contest/442/submission/144894116">codeforces submission 144894116</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;彩色树是边有颜色的有根树，其中每一种颜色的边集构成一条链.&lt;br&gt;定义一棵彩色树的权值为所有节点到根节点路径上不同颜色的数量的最大值.&lt;br&gt;现在有一棵不断变化的树，一开始只有1号点 (根节点)，接下来每个时刻长出一个新点，求每一时刻树的权值&lt;/p&gt;
&lt;p&gt;长出的节点数 $n\le10^5$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="树" scheme="https://gzezfisher.top/categories/%E6%A0%91/"/>
    
    <category term="树形DP" scheme="https://gzezfisher.top/categories/%E6%A0%91/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="树链剖分" scheme="https://gzezfisher.top/categories/%E6%A0%91/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
    
    <category term="树形DP" scheme="https://gzezfisher.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="树链剖分" scheme="https://gzezfisher.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>CF1633E Spanning Tree Queries</title>
    <link href="https://gzezfisher.top/2022/02/01/cf1633e/"/>
    <id>https://gzezfisher.top/2022/02/01/cf1633e/</id>
    <published>2022-02-01T13:00:00.000Z</published>
    <updated>2022-02-05T09:02:15.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个由 $n$ 个点 $m$ 条边组成的无向带权联通图，有 $k$ 个询问.<br>每次询问给出一个 $x$，对于每一条边，重新定义边权为 $|w-x|$ ($w$ 为原边权)，求新图上的最小生成树的边权和</p><p>$n\le 50, m\le 300, k\le 10^7$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>发现存在区间使得 $x$ 在区间内变化时，边权和可以表示为 $a+bx$，其中 $a$，$b$ 为常数</p><p>这样的区间需要满足的性质是，当 $x$ 在区间内变化时，图上的每条边大小关系都不会改变 (由kruskal，确定最小生成树上有哪些边)，且原边权 $w$ 与 $x$ 的大小关系不会改变 (可以打开绝对值)</p><p>显然这样的区间个数是 $\mathcal{O}(m^2)$ 级别的，下面给出证明</p><p>我们构造这样的区间<br>根据上面两个条件，令临界点 $p$ 使得 $\exists i, j$ 满足 $|w_i-p|&gt;|w_j-p|$ 且 $|w_i-(p+1)|\le|w_j-(p+1)|$<br>或 $\exists i$ 满足 $w_i\ge p$ 且 $w_i&lt;p+1$<br>即 $p=\lfloor\frac{w_i+w_j-1}{2}\rfloor$ 或 $w_i$</p><p>对所有临界点排序，相邻两个临界点 $p_1, p_2$ 之间的区间 $(p_1, p_2]$ 就是我们所构造的区间，显然这样的区间是满足上面条件的<br>不同的 $p$ 只有 $\mathcal{O}(m^2)$ 种，对应的区间个数也只有 $\mathcal{O}(m^2)$ 个</p><p>按证明中的构造方法构造出所有区间<br>对于每个区间，打开边权的绝对值，然后含参跑kruskal，得到 $a+bx$ 形式的答案<br>查询时二分 $x$ 所在的区间，带入 $x$ 求值即可</p><p>总的时间复杂度为 $\mathcal{O}(m^3\log m+k)$</p><p>代码 <a href="http://codeforces.com/contest/1633/submission/144838318">codeforces submission 144838318</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;有一个由 $n$ 个点 $m$ 条边组成的无向带权联通图，有 $k$ 个询问.&lt;br&gt;每次询问给出一个 $x$，对于每一条边，重新定义边权为 $|w-x|$ ($w$ 为原边权)，求新图上的最小生成树的边权和&lt;/p&gt;
&lt;p&gt;$n\le 50, m\le 300, k\le 10^7$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="图论" scheme="https://gzezfisher.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最小生成树" scheme="https://gzezfisher.top/categories/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    
    <category term="最小生成树" scheme="https://gzezfisher.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LUOGU P4119 Ynoi2018 未来日记</title>
    <link href="https://gzezfisher.top/2022/02/01/luogu4119/"/>
    <id>https://gzezfisher.top/2022/02/01/luogu4119/</id>
    <published>2022-02-01T04:27:48.000Z</published>
    <updated>2022-02-05T13:00:46.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个长度为 $n$ 的序列，共 $m$ 次操作：</p><ul><li><code>1 l r x y</code>，把区间 $[l, r]$ 内所有 $x$ 变成 $y$；</li><li><code>2 l r k</code>，查询区间 $[l, r]$ 内第 $k$ 小值.</li></ul><p>$1\le n, m\le 10^5$，任何时刻 $1\le a_i\le 10^5$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于这种复杂的修改操作，我们直接考虑分块</p><p>对序列和值域同时分块，令 $sum_{i, v}$ 表示前 $i$ 块内值 $v$ 的个数，$blsum_{i, j}$ 表示序列前 $i$ 块内值在值域第 $j$ 块内的个数</p><p>考虑查询，对于散块我们每次查询构造 $sctsum_{v}$ 表示在散块中值为 $v$ 的个数，$sctblsum_{i}$ 表示散块中值在值域第 $i$ 块内的个数</p><p>查询时我们对整块差分再加上散块的贡献，即可 $\Theta(1)$ 地查询区间 $[l, r]$ 内值为 $v$ 的个数和区间内值在值域第 $i$ 块中的个数</p><p>先枚举 $k$ 小值在值域中的哪一块，再枚举 $k$ 小值是该块中的哪一个值，一次查询的时间复杂度为 $\Theta(\sqrt{n})$</p><p>考虑修改，对于散块直接暴力修改即可</p><p>对于每个整块独立地给块内每一个值一个标号 $id$，颜色相同的有相同的标号，还需要维护值对标号的映射 $rep$ 和值对标号的映射 $col$</p><p>把 $x$ 变成 $y$ 时的两种情况：</p><ul><li>块内没有 $y$<br>将 $col_{rep_x}$ 设为 $y$，将 $rep_y$ 设为原来的 $rep_x$，将 $rep_x$ 清空</li><li>块内有 $y$<br>不太好处理，直接像对散块一样暴力修改<br>考虑这样做的时间复杂度<br>暴力修改的次数不多于所有块内不同值个数的和，一开始有 $\mathcal{O}(n)$ 个，每修改一次整块不会增加，只有散块可能增加1，所以总共暴力修改 $\mathcal{O}(n+m)$ 次，总的暴力修改复杂度即为 $\mathcal{O}((n+m)\sqrt{n})$</li></ul><p>最后是如何在散块操作前 “reset” 这一块<br>对于每个值用标号映射得到新的值，也就是将每个 $a_i$ 设为 $col_{id_i}$</p><p>总的时间复杂度为 $\mathcal{O}((n+m)\sqrt{n})$</p><p>代码<br><figure class="highlight cpp"><figcaption><span>P4119.cpp >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>, maxvs = <span class="number">316</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxs = <span class="number">360</span>, maxc = <span class="number">278</span>;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> lp[maxc + <span class="number">5</span>], rp[maxvs + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> bl[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> vlp[maxvs + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> vbl[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> sum[maxc + <span class="number">5</span>][maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> blsum[maxc + <span class="number">5</span>][maxvs + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> rep[maxc + <span class="number">5</span>][maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> col[maxc + <span class="number">5</span>][maxs + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> id[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> ccnt[maxc + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildUnion</span><span class="params">(<span class="keyword">int</span> bid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ccnt[bid]; i++)</span><br><span class="line">        rep[bid][col[bid][i]] = <span class="number">0</span>;</span><br><span class="line">    ccnt[bid] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lp[bid]; i &lt;= rp[bid]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rep[bid][a[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">            rep[bid][a[i]] = ++ccnt[bid];</span><br><span class="line">            col[bid][ccnt[bid]] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        id[i] = rep[bid][a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> bid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lp[bid]; i &lt;= rp[bid]; i++)</span><br><span class="line">        a[i] = col[bid][id[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> siz = <span class="built_in">min</span>(n, <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">sqrt</span>(<span class="number">1.3</span> * n)));</span><br><span class="line">    cnt = <span class="built_in">ceil</span>(<span class="number">1.</span> * n / siz);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        bl[i] = (i - <span class="number">1</span>) / siz + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        lp[i] = (i - <span class="number">1</span>) * siz + <span class="number">1</span>;</span><br><span class="line">        rp[i] = <span class="built_in">min</span>(n, i * siz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">        vbl[i] = (i - <span class="number">1</span>) / maxvs + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxvs + <span class="number">1</span>; i++)</span><br><span class="line">        vlp[i] = (i - <span class="number">1</span>) * maxvs + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= maxn; j++)</span><br><span class="line">            sum[i][j] = sum[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= maxvs + <span class="number">1</span>; j++)</span><br><span class="line">            blsum[i][j] = blsum[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lp[i]; j &lt;= rp[i]; j++) &#123;</span><br><span class="line">            sum[i][a[j]]++;</span><br><span class="line">            blsum[i][vbl[a[j]]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">buildUnion</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[maxn + <span class="number">5</span>], bltmp[maxvs + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        tmp[a[i]] += delta;</span><br><span class="line">        bltmp[vbl[a[i]]] += delta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lb = bl[l], rb = bl[r];</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (lb == rb) &#123;</span><br><span class="line">        <span class="built_in">reset</span>(lb);</span><br><span class="line">        <span class="built_in">copy</span>(a + l, a + r + <span class="number">1</span>, tmp + l);</span><br><span class="line">        <span class="built_in">nth_element</span>(tmp + l, tmp + l + k - <span class="number">1</span>, tmp + r + <span class="number">1</span>);</span><br><span class="line">        res = tmp[l + k - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">fill</span>(tmp + l, tmp + r + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">reset</span>(lb);</span><br><span class="line">        <span class="built_in">reset</span>(rb);</span><br><span class="line">        <span class="built_in">add</span>(l, rp[lb], <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(lp[rb], r, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, delta;</span><br><span class="line">        <span class="keyword">for</span> (; k - (delta = bltmp[i] + blsum[rb - <span class="number">1</span>][i] - blsum[lb][i]) &gt; <span class="number">0</span>;</span><br><span class="line">             i++)</span><br><span class="line">            k -= delta;</span><br><span class="line">        <span class="keyword">int</span> j = vlp[i];</span><br><span class="line">        <span class="keyword">for</span> (; k - (delta = tmp[j] + sum[rb - <span class="number">1</span>][j] - sum[lb][j]) &gt; <span class="number">0</span>; j++)</span><br><span class="line">            k -= delta;</span><br><span class="line">        res = j;</span><br><span class="line">        <span class="built_in">add</span>(l, rp[lb], <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(lp[rb], r, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> bid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> chcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == x) &#123;</span><br><span class="line">            a[i] = y;</span><br><span class="line">            chcnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[bid][x] -= chcnt;</span><br><span class="line">    sum[bid][y] += chcnt;</span><br><span class="line">    blsum[bid][vbl[x]] -= chcnt;</span><br><span class="line">    blsum[bid][vbl[y]] += chcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeBlock</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> bid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">reset</span>(bid);</span><br><span class="line">    <span class="built_in">change</span>(l, r, x, y, bid);</span><br><span class="line">    <span class="built_in">buildUnion</span>(bid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lb = bl[l], rb = bl[r];</span><br><span class="line">    <span class="keyword">if</span> (x == y || sum[rb][x] - sum[lb - <span class="number">1</span>][x] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt;= lb; i--) &#123;</span><br><span class="line">        sum[i][x] -= sum[i - <span class="number">1</span>][x];</span><br><span class="line">        sum[i][y] -= sum[i - <span class="number">1</span>][y];</span><br><span class="line">        blsum[i][vbl[x]] -= blsum[i - <span class="number">1</span>][vbl[x]];</span><br><span class="line">        blsum[i][vbl[y]] -= blsum[i - <span class="number">1</span>][vbl[y]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lb == rb)</span><br><span class="line">        <span class="built_in">changeBlock</span>(l, r, x, y, lb);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">changeBlock</span>(l, rp[lb], x, y, lb);</span><br><span class="line">        <span class="built_in">changeBlock</span>(lp[rb], r, x, y, rb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lb + <span class="number">1</span>; i &lt; rb; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[i][x] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum[i][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                col[i][rep[i][x]] = y;</span><br><span class="line">                <span class="built_in">swap</span>(rep[i][y], rep[i][x]);</span><br><span class="line">                blsum[i][vbl[y]] += sum[i][x];</span><br><span class="line">                blsum[i][vbl[x]] -= sum[i][x];</span><br><span class="line">                sum[i][y] = sum[i][x];</span><br><span class="line">                sum[i][x] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">changeBlock</span>(lp[i], rp[i], x, y, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lb; i &lt;= cnt; i++) &#123;</span><br><span class="line">        sum[i][x] += sum[i - <span class="number">1</span>][x];</span><br><span class="line">        sum[i][y] += sum[i - <span class="number">1</span>][y];</span><br><span class="line">        blsum[i][vbl[x]] += blsum[i - <span class="number">1</span>][vbl[x]];</span><br><span class="line">        blsum[i][vbl[y]] += blsum[i - <span class="number">1</span>][vbl[y]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="built_in">modify</span>(l, r, x, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(l, r, k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;有一个长度为 $n$ 的序列，共 $m$ 次操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 l r x y&lt;/code&gt;，把区间 $[l, r]$ 内所有 $x$ 变成 $y$；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 l r k&lt;/code&gt;，查询区间 $[l, r]$ 内第 $k$ 小值.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$1\le n, m\le 10^5$，任何时刻 $1\le a_i\le 10^5$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="根号算法" scheme="https://gzezfisher.top/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/"/>
    
    <category term="分块" scheme="https://gzezfisher.top/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E5%88%86%E5%9D%97/"/>
    
    
    <category term="分块" scheme="https://gzezfisher.top/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>UOJ435 Simple Tree</title>
    <link href="https://gzezfisher.top/2022/01/30/uoj435/"/>
    <id>https://gzezfisher.top/2022/01/30/uoj435/</id>
    <published>2022-01-30T09:58:38.000Z</published>
    <updated>2022-02-05T12:11:38.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一棵有根树，根为 $1$，点有点权.<br>现在有 $m$ 次操作，操作有3种：</p><ul><li><code>1 x y w</code>，将 $x$ 到 $y$ 的路径上的点点权加上 $w$ (其中 $w=\pm 1$)；</li><li><code>2 x y</code>，询问在 $x$ 到 $y$ 的路径上有多少个点点权 $&gt;0$；</li><li><code>3 x</code>，询问在 $x$ 的子树里的点有多少个点点权 $&gt;0$.</li></ul><p>强制在线，$n,m\le 10^5,-10^9\le\text{点权}\le10^9$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先考虑序列上的做法<br>问题比较复杂，我们用分块来处理</p><p>我们把每一块内部预先排好序，维护在排好序的块内下标最小的大于零点的下标 $pts$ 以及对于块中每个数第一个<strong>严格</strong>大于和小于该数的位置 $nxt$ 和 $lst$</p><ul><li>查询的时候，对于整块，用右端点减去 $pts$ 即可得到答案<br>对于散块暴力统计</li><li>修改的时候，对于整块，我们修改零点，然后尝试让 $pts$ 往 $nxt$ 或 $lst$ 跳<br>对于散块，暴力修改并归并排序</li></ul><p>把序列问题放在树上，一个显然的想法是树链剖分，$\mathcal{O}(n\log n+q\sqrt{n}\log{n})$，不足以通过此题</p><p>其实在树链剖分的情况下 $\sqrt{n}$ 的块长不是最优的<br>每次链的询问和修改，涉及的整块是 $\mathcal{O}(\sqrt{n})$ 级别的，然而涉及的散块元素个数是 $\mathcal{O}(\sqrt{n}\log{n})$ 级别的，因此块长 $\sqrt{n\log n}$ 时取到最优复杂度 $\mathcal{O}(n\log n+q\sqrt{n\log n})$</p><p>考虑使用一个分块上树通用的trick，对每条链单独分块<br>下面证明链操作的时间复杂度是 $\mathcal{O}(\sqrt{n})$</p><p>考虑一条竖直的 (即以一个点与其祖先为顶点) 链，因为任意一条链都可以由两条这样的链组成<br>设这条链从上到下依次经过的重链分别为 $lnk_0, lnk_1, …, lnk_k$<br>由树链剖分的性质，有</p><script type="math/tex; mode=display">\text{len}(lnk_i)\le\text{subtreeSize}(\text{top}(lnk_i))\le\frac{n}{2^i}</script><p>其中 $\text{top}(x)$ 表示链 $x$ 的链顶，$\text{len}(x)$ 表示 $x$ 的链长，$\text{subtreeSize}(u)$ 表示以 $u$ 为根的子树的大小</p><script type="math/tex; mode=display">\begin{align*}T(n)&=\sum_{0\le i\le k}\sqrt{\text{len}(lnk_i)}\\&\le\sum_{0\le i\le k}\sqrt{\frac{n}{2^i}}\\&=\sqrt{n}\sum_{0\le i\le k}\frac{1}{\sqrt{2}}^i\\&=\Theta(\sqrt{n})\end{align*}</script><p>即复杂度为 $\mathcal{O}(\sqrt{n})$</p><p>下面考虑子树查询</p><p>我们把每条重链按链顶dfn序排序，发现每棵子树都是由一条重链的一部分和排序后连续的完整重链构成<br>修改时，对于 $\mathcal{O}(\log n)$ 条被修改的重链，在树状数组上更新答案<br>子树询问时，区间查询即可</p><p>总复杂度为 $\mathcal{O}(n\log n+q\sqrt{n}+q\log^2 n)$</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>散块常数大，调一调参跑得快</p><p>代码<br><figure class="highlight cpp"><figcaption><span>uoj435.cpp >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>, maxs = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, T;</span><br><span class="line"><span class="keyword">int</span> val[maxn + <span class="number">5</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> stamp;</span><br><span class="line"><span class="keyword">int</span> dep[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> fa[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> heavy_son[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> siz[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> tp[maxn + <span class="number">5</span>], bt[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> id[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> lnk[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> lcnt;</span><br><span class="line"><span class="keyword">int</span> lid[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> minl[maxn + <span class="number">5</span>], maxl[maxn + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; g[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">        <span class="keyword">if</span> (v == f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span> (siz[v] &gt; siz[heavy_son[u]])</span><br><span class="line">            heavy_son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">    id[u] = ++stamp;</span><br><span class="line">    lnk[u] = top;</span><br><span class="line">    <span class="keyword">if</span> (u == top)</span><br><span class="line">        tp[++lcnt] = id[u];</span><br><span class="line">    <span class="keyword">if</span> (heavy_son[u] == <span class="number">0</span>)</span><br><span class="line">        bt[lcnt] = id[u];</span><br><span class="line">    lid[u] = lcnt;</span><br><span class="line">    minl[u] = lcnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (heavy_son[u])</span><br><span class="line">        <span class="built_in">dfs2</span>(heavy_son[u], u, top);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; g[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">        <span class="keyword">if</span> (v == f || v == heavy_son[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    maxl[u] = lcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fenwic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t[maxn + <span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= lcnt) &#123;</span><br><span class="line">            t[x] += y;</span><br><span class="line">            x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query_</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += t[x];</span><br><span class="line">            x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_</span>(r) - <span class="built_in">query_</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> tot[maxn + <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> a[maxn + <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> blg[maxn + <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> zero[maxn + <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> lp[maxn + <span class="number">5</span>], rp[maxn + <span class="number">5</span>], pts[maxn + <span class="number">5</span>];</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp1[maxs + <span class="number">5</span>], tmp2[maxs + <span class="number">5</span>];</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; sorted[maxn + <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> nxt[maxn + <span class="number">5</span>], lst[maxn + <span class="number">5</span>], lpts[maxn + <span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> bsiz = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(<span class="number">.12</span> * len));</span><br><span class="line">        <span class="keyword">int</span> bcnt = <span class="built_in">ceil</span>(<span class="number">1.</span> * len / bsiz);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            a[i] = arr[i];</span><br><span class="line">            sorted[i] = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= cnt + bcnt; i++) &#123;</span><br><span class="line">            lp[i] = l + (i - cnt - <span class="number">1</span>) * bsiz;</span><br><span class="line">            rp[i] = <span class="built_in">min</span>(r, l + (i - cnt) * bsiz - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = lp[i]; j &lt;= rp[i]; j++)</span><br><span class="line">                blg[j] = i;</span><br><span class="line">            <span class="built_in">sort</span>(sorted + lp[i], sorted + rp[i] + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">calcNxtLst</span>(i);</span><br><span class="line">            tot[lk] += rp[i] - pts[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt += bcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calcNxtLst</span><span class="params">(<span class="keyword">int</span> bid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rp[bid], j = rp[bid] + <span class="number">1</span>; i &gt;= lp[bid]; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; lp[bid] &amp;&amp; sorted[i].first == sorted[i - <span class="number">1</span>].first)</span><br><span class="line">                i--;</span><br><span class="line">            nxt[i] = j;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= rp[bid])</span><br><span class="line">                lst[j] = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lpts[bid] = i;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">        lst[lp[bid]] = lp[bid];</span><br><span class="line">        pts[bid] = rp[bid] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lp[bid]; i &lt;= rp[bid]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sorted[i].first &gt; zero[bid]) &#123;</span><br><span class="line">                pts[bid] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> bid, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta, <span class="keyword">int</span> lk)</span> </span>&#123;</span><br><span class="line">        tot[lk] += pts[bid];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">            a[i] += delta;</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lp[bid]; i &lt;= rp[bid]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sorted[i].second &gt;= l &amp;&amp; sorted[i].second &lt;= r)</span><br><span class="line">                tmp1[++cnt1] =</span><br><span class="line">                    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(sorted[i].first + delta, sorted[i].second);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp2[++cnt2] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">merge</span>(tmp1 + <span class="number">1</span>, tmp1 + cnt1 + <span class="number">1</span>, tmp2 + <span class="number">1</span>, tmp2 + cnt2 + <span class="number">1</span>,</span><br><span class="line">              sorted + lp[bid]);</span><br><span class="line">        <span class="built_in">calcNxtLst</span>(bid);</span><br><span class="line">        tot[lk] -= pts[bid];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta, <span class="keyword">int</span> lk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lb = blg[l], rb = blg[r];</span><br><span class="line">        <span class="keyword">if</span> (lb == rb)</span><br><span class="line">            <span class="built_in">mergeSort</span>(lb, l, r, delta, lk);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">mergeSort</span>(lb, l, rp[lb], delta, lk);</span><br><span class="line">            <span class="built_in">mergeSort</span>(rb, lp[rb], r, delta, lk);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lb + <span class="number">1</span>; i &lt; rb; i++) &#123;</span><br><span class="line">                tot[lk] += pts[i];</span><br><span class="line">                zero[i] -= delta;</span><br><span class="line">                <span class="keyword">if</span> (pts[i] &gt; rp[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sorted[lpts[i]].first &gt; zero[i])</span><br><span class="line">                        pts[i] = lpts[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (delta == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sorted[lst[pts[i]]].first &gt; zero[i])</span><br><span class="line">                            pts[i] = lst[pts[i]];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sorted[pts[i]].first &lt;= zero[i])</span><br><span class="line">                        pts[i] = nxt[pts[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                tot[lk] -= pts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lb = blg[l], rb = blg[r];</span><br><span class="line">        <span class="keyword">if</span> (lb == rb) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; zero[lb])</span><br><span class="line">                    res++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= rp[lb]; i++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; zero[lb])</span><br><span class="line">                    res++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lp[rb]; i &lt;= r; i++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; zero[rb])</span><br><span class="line">                    res++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lb + <span class="number">1</span>; i &lt; rb; i++)</span><br><span class="line">                res += rp[i] - pts[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bl;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryLnk</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lnk[x] != lnk[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[lnk[x]] &lt; dep[lnk[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        res += bl.<span class="built_in">query</span>(tp[lid[x]], id[x]);</span><br><span class="line">        x = fa[lnk[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[y] &lt; dep[x])</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    res += bl.<span class="built_in">query</span>(id[x], id[y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querySubtree</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bl.<span class="built_in">query</span>(id[x], bt[lid[x]]) + bit.<span class="built_in">query</span>(minl[x], maxl[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyLnk</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lnk[x] != lnk[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[lnk[x]] &lt; dep[lnk[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">int</span> ori = bl.tot[lid[x]];</span><br><span class="line">        bl.<span class="built_in">modify</span>(tp[lid[x]], id[x], delta, lid[x]);</span><br><span class="line">        bit.<span class="built_in">modify</span>(lid[x], bl.tot[lid[x]] - ori);</span><br><span class="line">        x = fa[lnk[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[y] &lt; dep[x])</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">int</span> ori = bl.tot[lid[x]];</span><br><span class="line">    bl.<span class="built_in">modify</span>(id[x], id[y], delta, lid[x]);</span><br><span class="line">    bit.<span class="built_in">modify</span>(lid[x], bl.tot[lid[x]] - ori);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;q, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val[id[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lcnt; i++) &#123;</span><br><span class="line">        bl.<span class="built_in">resize</span>(val, tp[i], bt[i], i);</span><br><span class="line">        bit.<span class="built_in">modify</span>(i, bl.tot[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lstans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="number">1</span>)</span><br><span class="line">            x ^= lstans;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;y, &amp;w);</span><br><span class="line">            <span class="keyword">if</span> (T == <span class="number">1</span>)</span><br><span class="line">                y ^= lstans;</span><br><span class="line">            <span class="built_in">modifyLnk</span>(x, y, w);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">            <span class="keyword">if</span> (T == <span class="number">1</span>)</span><br><span class="line">                y ^= lstans;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lstans = <span class="built_in">queryLnk</span>(x, y));</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lstans = <span class="built_in">querySubtree</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;有一棵有根树，根为 $1$，点有点权.&lt;br&gt;现在有 $m$ 次操作，操作有3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 x y w&lt;/code&gt;，将 $x$ 到 $y$ 的路径上的点点权加上 $w$ (其中 $w=\pm 1$)；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 x y&lt;/code&gt;，询问在 $x$ 到 $y$ 的路径上有多少个点点权 $&amp;gt;0$；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3 x&lt;/code&gt;，询问在 $x$ 的子树里的点有多少个点点权 $&amp;gt;0$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;强制在线，$n,m\le 10^5,-10^9\le\text{点权}\le10^9$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="根号算法" scheme="https://gzezfisher.top/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/"/>
    
    <category term="分块" scheme="https://gzezfisher.top/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E5%88%86%E5%9D%97/"/>
    
    
    <category term="分块" scheme="https://gzezfisher.top/tags/%E5%88%86%E5%9D%97/"/>
    
    <category term="树链剖分" scheme="https://gzezfisher.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>CF1039D You Are Given a Tree</title>
    <link href="https://gzezfisher.top/2022/01/29/cf1039d/"/>
    <id>https://gzezfisher.top/2022/01/29/cf1039d/</id>
    <published>2022-01-29T01:44:24.000Z</published>
    <updated>2022-02-05T12:09:40.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一棵有 $n$ 个节点的树. 对于满足 $1\le k\le n$ 的每一个 $k$，把树分成若干条包含 $k$ 个顶点的链，其中每个点最多属于一条链，问最多能分得几条链.</p><p>$n\le 10^5$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑 $k$ 固定时怎么做</p><p>我们自下而上贪心，对于一个点，如果在它的子树内有一条经过该点且不经过以被使用点的链，那么我们就将这条链计入答案并将该点标记为使用过</p><p>简单证明一下：<br>对于点 $u$ 满足在其子树内有一条经过该点且不经过以被使用点的链，如果这条链不计入答案，而是选取一条经过 $u$ 的但不完全在 $u$ 子树中的链，这样划分的链数不会增加，反而会占用这条链在点 $u$ 子树外的点<br>因此，按照上述方法贪心是最优的</p><p>令 $f_i$ 表示 $k=i$ 时的答案，显然有 $f_i\le\lfloor\frac{n}{i}\rfloor$</p><p>类似除法分块，$f_i$ 一共只有 $\mathcal{O}(\sqrt{n})$ 种取值<br>证明如下：</p><ul><li>$i\le \sqrt{n}$<br> 显然只有不超过 $\sqrt{n}$ 种取值</li><li>$i&gt;\sqrt{n}$<br> $f_i&lt;\lfloor\frac{n}{\sqrt{n}}\rfloor=\sqrt{n}$<br> 显然也只有不超过 $\sqrt{n}$ 种取值</li></ul><p>因此我们对于每一种取值二分右端点，时间复杂度为 $\mathcal{O}(n\sqrt{n}\log n)$，不足以通过此题</p><p>观察到前几种取值比较密集，对每种取值二分是很浪费的，考虑对前 $T$ 项直接暴力，只对后面的 $\mathcal{O}(\frac{n}{T})$ 种取值二分</p><p>时间复杂度为 $\mathcal{O}(nT+\frac{n}{T}\log n)$，$T$ 取 $\sqrt{n\log n}$ 时有最优复杂度 $\mathcal{O}(n\sqrt{n\log n})$</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>实现的时候注意常数，特别是不要每次贪心都dfs一遍，可以直接在dfs序上贪心</p><p>代码 <a href="https://codeforces.com/contest/1039/submission/144337474">codeforces submission 144337474</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一棵有 $n$ 个节点的树. 对于满足 $1\le k\le n$ 的每一个 $k$，把树分成若干条包含 $k$ 个顶点的链，其中每个点最多属于一条链，问最多能分得几条链.&lt;/p&gt;
&lt;p&gt;$n\le 10^5$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="根号算法" scheme="https://gzezfisher.top/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/"/>
    
    <category term="根号分治" scheme="https://gzezfisher.top/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
    
    
    <category term="贪心" scheme="https://gzezfisher.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="二分" scheme="https://gzezfisher.top/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="除法分块" scheme="https://gzezfisher.top/tags/%E9%99%A4%E6%B3%95%E5%88%86%E5%9D%97/"/>
    
    <category term="根号分治" scheme="https://gzezfisher.top/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>CF587F Duff is Mad</title>
    <link href="https://gzezfisher.top/2022/01/28/cf587f/"/>
    <id>https://gzezfisher.top/2022/01/28/cf587f/</id>
    <published>2022-01-28T12:34:33.000Z</published>
    <updated>2022-02-19T06:34:18.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个字符串 $S_{1…n}$.<br>定义 $\text{occur}(t, s)$ 为 字符串 $t$ 在字符串 $s$ 中的出现次数. 有 $q$ 次询问，每次给出 $l$，$r$ 和 $k$，输出 $\sum\limits_{l\le i\le r}\text{occur}(s_i, s_k)$.</p><p>$n,k,\sum |s_i|\le 10^5$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们对所有串建立fail树</p><p>令 $p_{i,j}$ 表示串 $s_i$ 的前 $j$ 个字符构成的子串在AC自动机上对应点的编号，$end_{i}$ 表示串 $s_i$ 在AC自动机上对应点的编号<br>$s_i$ 在 $s_k$ 中出现就代表 $s_i$ 是 $s_k$ 某个前缀的后缀，因此有 </p><script type="math/tex; mode=display">\sum_{l\le i\le r}\text{occur}(s_i, s_k)=\sum_{l\le i\le r}\sum_{1\le j\le \text{len}_k}\text{isanc}(end_{i}, p_{k, j})</script><p>其中 $\text{isanc}(x, y)$ 表示在fail树上 $x$ 是否为 $y$ 的祖先</p><p>看到 $\sum |s_i|\le 10^5$ 这条限制，容易想到对于 $|s_k|$ 根号分治</p><p>令 $M=\sum |s_i|$</p><ul><li>$|s_k|&lt;=T$<br> 容易想到一种做法，$\forall l\le i\le r$，对所有以 $end_i$ 为根的子树的所有点加1，然后查询所有 $p_{k,i}$ 点上的值之和<br> 把每个询问差分为成 $[1, l-1]$ 和 $[1, r]$ 两个区间，然后离线下来按右端点排序，维护区间修改单点查询<br> 树状数组可以做到 $\mathcal{O}(qT\log M+n\log M)$，当然更快的做法是分块的 $\mathcal{O}(qT+n\sqrt{M})$</li><li>$|s_k|&gt;T$<br> 满足这个条件的 $k$ 数量是 $\mathcal{O}(\frac{M}{T})$ 级别的，因此考虑对所有的 $k$ 预处理<br> 考虑另一种做法，把所有 $p_{k,i}$ 标上1，然后查询 $\forall l\le i\le r$，$end_i$ 子树和之和<br> 预处理时我们对 $end_i$ 的子树和做前缀和，询问的差分即可<br> $\mathcal{O}(q+\frac{M}{T}\times n)$</li></ul><p>选择一个合适的 $T$，不妨认为 $n$，$M$ 和 $q$ 同阶，$T$ 取 $\sqrt{M}$ 即可<br>复杂度可以认为是 $\mathcal{O}(n\sqrt{M})$</p><p>代码 <a href="https://codeforces.com/contest/587/submission/144319232">codeforces submission 144319232</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定 $n$ 个字符串 $S_{1…n}$.&lt;br&gt;定义 $\text{occur}(t, s)$ 为 字符串 $t$ 在字符串 $s$ 中的出现次数. 有 $q$ 次询问，每次给出 $l$，$r$ 和 $k$，输出 $\sum\limits_{l\le i\le r}\text{occur}(s_i, s_k)$.&lt;/p&gt;
&lt;p&gt;$n,k,\sum |s_i|\le 10^5$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="根号算法" scheme="https://gzezfisher.top/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/"/>
    
    <category term="字符串" scheme="https://gzezfisher.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="根号分治" scheme="https://gzezfisher.top/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
    
    <category term="AC自动机" scheme="https://gzezfisher.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
    <category term="根号分治" scheme="https://gzezfisher.top/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
    
    <category term="分块" scheme="https://gzezfisher.top/tags/%E5%88%86%E5%9D%97/"/>
    
    <category term="AC自动机" scheme="https://gzezfisher.top/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    <category term="fail树" scheme="https://gzezfisher.top/tags/fail%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF1118F2 Tree Cutting (Hard Version)</title>
    <link href="https://gzezfisher.top/2022/01/27/cf1118f2/"/>
    <id>https://gzezfisher.top/2022/01/27/cf1118f2/</id>
    <published>2022-01-27T09:39:09.000Z</published>
    <updated>2022-02-15T12:24:02.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个有 $n$ 个节点的树，节点可能有颜色，共 $k$ 种颜色，编号 $1…k$，保证每种颜色都出现. 有的点没有颜色，用 $0$ 表示. 将其划分为 $k$ 个联通块，是每个联通块中有且仅有一种颜色，颜色为 $0$ 的节点可以在任意联通块中. 求有多少中划分的方案.</p><p>$2\le k\le n\le 3\times 10^5$，答案对 $998244353$ 取模.<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>将归类视为染色</p><p>显然有一些点的染色是确定的，一些点可以染上多种颜色，其中所有颜色为 $c$ 的点与它们的LCA的路径上的点确定染上颜色 $c$</p><p>先按照如下流程将这些颜色确定的点染色：</p><ol><li>找出同一颜色 $c$ 的点的LCA</li><li>依次从每个点开始往父亲上跳，一边跳一边染色</li><li>跳到一个点已经染色或已经到达LCA即可停止，如果跳到的点已经染上颜色且不为 $c$ 则两种颜色构成的联通块必然重叠，即没有合法方案</li></ol><p>接下来考虑树形DP<br>令 $f_{u,0}$ 表示在以 $u$ 为根的子树中，最上方联通块不包含已染色点的方案数，$f_{u,1}$ 表示在以 $u$ 为根的子树中，最上方联通块包含已染色点的方案数，$c_u$ 表示点 $u$ 的颜色</p><p>分两种情况讨论转移：</p><ul><li>$c_u\not=0$<br>显然 $f_{u, 0}=0$<br>对于 $f_{u, 1}$，再分情况讨论：<ul><li>$v\in\text{son}_u,c_v\not=0$<br>能够确定边 $(u, v)$ 是否删去，对 $f_{u, 1}$ 贡献为 $f_{v, 1}=f_{v, 0}+f_{v, 1}$</li><li>$v\in\text{son}_u,c_v=0$<br>若边 $(u, v)$ 删去，$v$ 所在联通块必须有色，否则该联通块将不包含任何一种颜色，对 $f_{u, 1}$ 贡献为 $f_{v, 1}$<br>若边 $(u, v)$ 保留，$v$ 所在联通块必须无色，否则该联通块将包含多种颜色，对 $f_{u, 1}$ 贡献为 $f_{v, 0}$<br>总贡献为 $f_{v, 0}+f_{v, 1}$</li></ul>综上，$f_{u, 1}=\prod\limits_{v\in\text{son}_u}f_{v, 0}+f_{v, 1}$</li><li>$c_u=0$<br>类似的，$f_{u, 0}=\prod\limits_{v\in\text{son}_u}f_{v, 0}+f_{v, 1}$<br>对于 $f_{u, 1}$，枚举 $u$ 继承哪一个儿子节点的颜色，即 $f_{u, 1}=\sum\limits_{v_1\in\text{son}_u}f_<br>{v_1, 1}\times\prod\limits_{v_2\in\text{son}_u,v_2\not=v_1}f_{v_2, 0}+f_{v_2, 1}$<br>对于这条式子维护 $f_{v, 0}+f_{v, 1}$ 的前缀积和后缀积即可</li></ul><p>总的时间复杂度 $\Theta(n)$ 到 $\Theta(n\log n)$，取决于求LCA的算法</p><p>代码 <a href="http://codeforces.com/contest/1118/submission/143330738">codeforces submission 143330738</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个有 $n$ 个节点的树，节点可能有颜色，共 $k$ 种颜色，编号 $1…k$，保证每种颜色都出现. 有的点没有颜色，用 $0$ 表示. 将其划分为 $k$ 个联通块，是每个联通块中有且仅有一种颜色，颜色为 $0$ 的节点可以在任意联通块中. 求有多少中划分的方案.&lt;/p&gt;
&lt;p&gt;$2\le k\le n\le 3\times 10^5$，答案对 $998244353$ 取模.&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="树" scheme="https://gzezfisher.top/categories/%E6%A0%91/"/>
    
    <category term="树形DP" scheme="https://gzezfisher.top/categories/%E6%A0%91/%E6%A0%91%E5%BD%A2DP/"/>
    
    
    <category term="树形DP" scheme="https://gzezfisher.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>CF802O April Fools&#39; Problem (hard)</title>
    <link href="https://gzezfisher.top/2022/01/26/cf802o/"/>
    <id>https://gzezfisher.top/2022/01/26/cf802o/</id>
    <published>2022-01-26T14:20:22.000Z</published>
    <updated>2022-02-15T12:20:58.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有 $n$ 道题，第 $i$ 天可以花费 $a_i$ 准备一道题，花费 $b_i$ 打印一道题，每天最多准备一道题，打印一道题，准备的题可以留到以后打印，求打印 $k$ 道题的最小花费.</p><p>$1\le k\le n\le 5\times10^5$<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然可以费用流解决，建图如下.<br><img src="/img/cf802o/flow.svg" alt="费用流建图"></p><p>考虑优化费用流</p><p><article class="message">  <div class="message-header">    <p>引理</p>  </div>  <div class="message-body">    初始不含负圈的图在费用流的增广过程中不会出现负圈  </div></article>根据引理得，每次增广的增广路都是一条形如 $S\rightarrow X\rightarrow Y\rightarrow T’\rightarrow T$ 的路径，一共增广 $k$ 次.</p><p>设 $f_i$ 表示在残流网络上 $i+1$ 点向 $i$ 的流量，则一条增广路合法当且仅当 $S\rightarrow X,Y\rightarrow T’$ 这两条边有流量且满足下列两个条件之一：</p><ul><li>$X\le Y$</li><li>$X&gt;Y\land \min_{Y\le i&lt;X}f_i&gt;0$</li></ul><p>尝试用线段树来模拟这一过程，对于每一个区间 $[l, r]$，维护 $a$ 的最小值计为 $\text{minA}$，$b$ 的最小值计为 $\text{minB}$，从 $x$ 到 $l$ 有流量的最小 $a_x$ 计为 $\text{flowA}$，从 $r+1$ 到 $x$ 有流量的最小 $b_x$ 计为 $\text{flowB}$，从左到右的最小费用流计为 $\text{flowLtoR}$，从右到左的最小费用流计为 $\text{flowRtoL}$，从 $r+1$ 到 $l$ 的流量计为 $\text{minFlow}$</p><p>每找到一条增广路，在线段树上更新流量并把 $a_X,b_Y$ 设为 $\text{Infinity}$ 标记 $S\rightarrow X,Y\rightarrow T’$ 这两条边没有流量</p><p>这时候我们发现这个做法是不可行的，因为我们没法对流量快速地区间修改</p><p>发现 $f_n$ 的值总是 $0$，于是令 $\text{flowA}$，$\text{flowB}$ 和 $\text{flowRtoL}$ 取<strong>整个区间每条边的流量都减去 $\text{minFlow}$</strong>时的值，这样一来不影响区间 $[1, n]$ (也就是我们需要查询的区间) 的答案，二来区间修改时我们只需要更新流量</p><p>为了方便pushup，还需要 $\text{minFlowRtoL}$ 表示假设区间内从右到左的每条边都有流量时，从右到左最小的费用</p><p>pushup的时候，假设当前点为 $u$，它的左儿子和右儿子分别是 $ls$ 和 $rs$<br>$\text{flowLtoR}_u=\min\{\text{flowLtoR}_{ls},\text{flowLtoR}_{rs},\text{minA}_{ls}+\text{minB}_{rs}\}$<br>$\text{minFlowRtoL}_u$ 是类似的<br>剩下的需要讨论</p><ul><li>$\text{minFlow}_{ls}&gt;\text{minFlow}_{rs}$<br>$\text{flowA}_u=\min\{\text{minA}_{ls},\text{flowA}_{rs}\}$<br>$\text{flowB}_u=\text{flowB}_{rs}$<br>$\text{flowRtoL}_u=\min\{\text{minFlowRtoL}_{ls},\text{flowRtoL}_{rs},\text{minB}_{ls}+\text{flowA}_{rs}\}$</li><li>$\text{minFlow}_{ls}&lt;\text{minFlow}_{rs}$<br>类似的</li><li>$\text{minFlow}_{ls}=\text{minFlow}_{rs}$<br>$\text{flowA}_u=\text{flowA}_{ls}$<br>$\text{flowB}_u=\text{flowB}_{rs}$<br>$\text{flowRtoL}_u=\min\{\text{flowRtoL}_{ls},\text{flowRtoL}_{rs},\text{minB}_{ls}+\text{minA}_{rs}\}$</li></ul><p>每次增广的时间复杂度可以做到 $\Theta(\log n)$，总时间复杂度为 $\Theta(k\log n)$</p><p>代码 <a href="http://codeforces.com/contest/802/submission/143973639">codeforces submission 143973639</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;有 $n$ 道题，第 $i$ 天可以花费 $a_i$ 准备一道题，花费 $b_i$ 打印一道题，每天最多准备一道题，打印一道题，准备的题可以留到以后打印，求打印 $k$ 道题的最小花费.&lt;/p&gt;
&lt;p&gt;$1\le k\le n\le 5\times10^5$&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="图论" scheme="https://gzezfisher.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="https://gzezfisher.top/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="数据结构" scheme="https://gzezfisher.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="https://gzezfisher.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
    <category term="网络流" scheme="https://gzezfisher.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="线段树" scheme="https://gzezfisher.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF997D Cycles in product</title>
    <link href="https://gzezfisher.top/2022/01/26/cf997d/"/>
    <id>https://gzezfisher.top/2022/01/26/cf997d/</id>
    <published>2022-01-26T11:30:05.000Z</published>
    <updated>2022-02-02T08:45:06.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你大小为 $n_1, n_2$​的两棵树 $T_1, T_2$​，构造一张新图，该图中每一个点的编号为 $(u,v)$。如果在 $T_1$ ​中， $u_1$ ​和$u_2$ ​之间有边，那么在该图上，对于任意 $1\le v\le n_2$，$(u_1, v)$ 和 $(u_2, v)$ 之间有边。同样，如果在 $T_2$ ​中，$v_1$ ​和$v_2$​之间有边，那么在图上，对于任意 $1\le u\le n_1$，$(u, v_1)$ 和 $(u, v_2)$ 之间有边.<br>求这个图上长度为 $K$ 的环有多少个，环可以不为简单环，起始点或方向不同的环视为不同的环.</p><p>$n_1, n_2\le 4000, K\le 75$，答案对 $998244353$ 取模.<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$T_1$ 上一个长度为 $K_1$ 的环和 $T_2$ 上一个长度为 $K_2$ 的环以不同方式组合对应图上 $\begin{pmatrix}K_1+K_2\\k_1\end{pmatrix}$ 个环<br>即答案为 $\sum\limits_{0\le i\le K}F1_i\times F2_{K-i}\times\begin{pmatrix}K\\i\end{pmatrix}$，其中 $F1_i$ 表示 $T_1$ 上长度为 $i$ 的环的个数，$F2_i$ 表示 $T_2$ 上长度为 $i$ 的环的个数</p><p>我们把每个点作为起始点分别计算，考虑到树上所有的环长度均为偶数，令 $f_{u, k}$ 表示以 $u$ 为起始点，长度为 $2\times k$ 的环的个数，有 $F_{2\times k}=\sum\limits_u f_{u, k}$<br>由于从父亲节点往儿子节点转移十分困难，不妨对于每个点只考虑在其子树中的环然后换根DP<br>考虑转移</p><script type="math/tex; mode=display">f_{u,k}=\sum_{0\le t<k}f_{u,t}\sum_{v\in \text{son}_u}f_{v,k-t-1}</script><p>令 $h_{u,k}=\sum\limits_{v\in \text{son}_u}f_{v,k-t-1}$，有</p><script type="math/tex; mode=display">f_{u,k}=\sum_{0\le t<k}f_{u,t}\times h_{u, k-t-1}</script><p>换根DP维护 $h$，再通过 $h$ 计算 $f$<br>$\Theta((n_1+n_2)\times K^2)$ 足以通过此题</p><p>代码 <a href="http://codeforces.com/contest/997/submission/143516835">codeforces submission 143516835</a></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>复杂度瓶颈在 $f$ 的计算，考虑优化这一过程</p><p>令 $h’_{u,k}=h_{u,k-1}$，有</p><script type="math/tex; mode=display">f_{u,k}=\sum_{0\le t<k}f_{u,t}\times h'_{u,k-t}</script><p>令$G_u(x)=\sum_{1\le i\le k}h’_{u,i}\times x^i$，有</p><script type="math/tex; mode=display">\begin{align*}f_{u,k}&=[x^k]\sum_{1\le i\le k}G_u(x)^i\\&=[x^k]\frac{G_u(x)^{k+1}-G_u(x)}{G_u(x)-1}\end{align*}</script><p>多项式快速幂和求逆可以做到 $\Theta((n_1+n_2)K\log K)$ 的复杂度</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你大小为 $n_1, n_2$​的两棵树 $T_1, T_2$​，构造一张新图，该图中每一个点的编号为 $(u,v)$。如果在 $T_1$ ​中， $u_1$ ​和$u_2$ ​之间有边，那么在该图上，对于任意 $1\le v\le n_2$，$(u_1, v)$ 和 $(u_2, v)$ 之间有边。同样，如果在 $T_2$ ​中，$v_1$ ​和$v_2$​之间有边，那么在图上，对于任意 $1\le u\le n_1$，$(u, v_1)$ 和 $(u, v_2)$ 之间有边.&lt;br&gt;求这个图上长度为 $K$ 的环有多少个，环可以不为简单环，起始点或方向不同的环视为不同的环.&lt;/p&gt;
&lt;p&gt;$n_1, n_2\le 4000, K\le 75$，答案对 $998244353$ 取模.&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="树" scheme="https://gzezfisher.top/categories/%E6%A0%91/"/>
    
    <category term="树形DP" scheme="https://gzezfisher.top/categories/%E6%A0%91/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="多项式" scheme="https://gzezfisher.top/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
    <category term="树形DP" scheme="https://gzezfisher.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="多项式" scheme="https://gzezfisher.top/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CF717A Festival Organization</title>
    <link href="https://gzezfisher.top/2022/01/26/cf717a/"/>
    <id>https://gzezfisher.top/2022/01/26/cf717a/</id>
    <published>2022-01-26T08:34:11.000Z</published>
    <updated>2022-01-30T12:14:23.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个合法的串定义为：长度在 $[l, r]$ 之间，且只含 $0,1$，并且不存在连续 $2$ 个或更多的 $0$.<br>现在要选出 $k$ 个长度相同的不同的合法的串，问有几种选法，答案模 $10^9+7$.</p><p>$1\le l\le r\le10^{18}, 1\le k\le200$.<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设 $F_{i,j}$ 表示长度为 $i$, 以 $j$ 结尾的合法串个数.<br>有 <script type="math/tex">\left\{      \begin{array}{**lr**}      F_{i,0}=F_{i-1,1} &  \\      F_{i,1}=F_{i-1,0}+F_{i-1,1} &     \end{array}  \right.</script><br>即 <script type="math/tex">\left\{      \begin{array}{**lr**}      F_{i,0}=\text{Fib}_{i} &  \\      F_{i,1}=\text{Fib}_{i+1} &     \end{array}  \right.</script><br>所以答案 <script type="math/tex">\text{Ans}=\sum\limits_{l+2\le i\le r+2}\begin{pmatrix}\text{Fib}_i\\k\end{pmatrix}</script></p><script type="math/tex; mode=display">\begin{align*}    \text{Ans}    =&\sum_{l+2\leq i\leq r+2} \begin{pmatrix}{\text{Fib}_i}\\k\end{pmatrix}\\    =&\frac{1}{k!}\sum_{l+2\le i\le r+2} {\text{Fib}_i}^{\underline{k}}\\    =&\frac{1}{k!}\sum_{l+2\le i\le r+2}\sum_{1\le j\le k}(-1)^{k-j}\begin{bmatrix}k\\ j \end{bmatrix}{\text{Fib}_i}^j\\    =&\frac{1}{k!}\sum_{1\le i\le k}(-1)^{k-i}\begin{bmatrix}k\\ i \end{bmatrix}\sum_{l+2\le j\le r+2}{\text{Fib}_j}^i\end{align*}</script><p>考虑带入斐波那契数的通项，令 $A=\frac{1+\sqrt{5}}{2}, B=\frac{1-\sqrt{5}}{2}$</p><script type="math/tex; mode=display">\begin{align*}    \text{Ans}    =&\frac{1}{k!}\sum_{1\le i\le k}(-1)^{k-i}\begin{bmatrix}k\\ i \end{bmatrix}\sum_{l+2\le j\le r+2}[{\frac{1}{\sqrt{5}}(A^j-B^j)}]^i\\    =&\frac{1}{k!}\sum_{1\le i\le k}(-1)^{k-i}\begin{bmatrix}k\\ i \end{bmatrix}(\frac{1}{\sqrt{5}})^i\sum_{l+2\le j\le r+2}\sum_{0\le p\le i}\begin{pmatrix}i\\p\end{pmatrix}(-1)^p(A^{i-p}B^p)^j\\    =&\frac{1}{k!}\sum_{1\le i\le k}(-1)^{k-i}\begin{bmatrix}k\\ i \end{bmatrix}(\frac{1}{\sqrt{5}})^i\sum_{0\le j\le i}\begin{pmatrix}i\\j\end{pmatrix}(-1)^j\sum_{l+2\le p\le r+2}(A^{i-j}B^j)^p\end{align*}</script><p>等比数列求和快速计算式子后面部分<br>$\Theta(k^2\times(\log l+\log r))$</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>本题涉及对 $\sqrt{5}$ 的计算，然而在模 $10^9+7$ 意义下 $5$ 没有二次剩余，扩域维护即可</p><p>代码 <a href="http://codeforces.com/contest/717/submission/137205589">codeforces submission 137205589</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;一个合法的串定义为：长度在 $[l, r]$ 之间，且只含 $0,1$，并且不存在连续 $2$ 个或更多的 $0$.&lt;br&gt;现在要选出 $k$ 个长度相同的不同的合法的串，问有几种选法，答案模 $10^9+7$.&lt;/p&gt;
&lt;p&gt;$1\le l\le r\le10^{18}, 1\le k\le200$.&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="组合" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"/>
    
    
    <category term="斯特林数" scheme="https://gzezfisher.top/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
    <category term="二项式定理" scheme="https://gzezfisher.top/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>UOJ450 复读机</title>
    <link href="https://gzezfisher.top/2021/10/16/uoj450/"/>
    <id>https://gzezfisher.top/2021/10/16/uoj450/</id>
    <published>2021-10-16T08:40:00.000Z</published>
    <updated>2022-01-27T13:58:33.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$k$ 种球，每种个数必须是 $d$ 的倍数，共 $n$ 个，求排成一行的方案数.</p><p>$n\le 10^9, k\le 5\times10^5, d\le 3$，答案对 $19491001$ 取模.<br><span id="more"></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><script type="math/tex; mode=display">\begin{align*}\text{Ans}&=n!\sum_{i_1 \ge 0,d\mid i_1}\frac{1}{i_1!}\sum_{0\le i_2,d\mid i_2}\frac{1}{i_2!}\cdots\sum_{0\le i_k,d\mid i_k}\frac{1}{i_k!}\\&=[x^n]n!(\sum_{i\ge 0,d\mid i}\frac{x^i}{i!})^k\\\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\sum_{i\ge 0,d\mid i}\frac{x^i}{i!}&=\sum_{i\ge 0}\frac{x^i}{i!}\frac{1}{d}\sum_{0\le j < d}{\omega_d^j}^i& \text{单位根反演}\\&=\frac{1}{d}\sum_{0\le j < d}\sum_{i\ge 0}\frac{(x\omega_d^j)^i}{i!}\\&=\frac{1}{d}\sum_{0\le j < d}e^{x\omega_d^j}& \text{泰勒展开}\\\end{align*}</script><p>$d=2$：</p><script type="math/tex; mode=display">\begin{align*}\sum_{i\ge 0,d\mid i}\frac{x^i}{i!}&=\frac{1}{d}\sum_{0\le j < d}e^{x\omega_d^j}\\&=\frac{e^x+e^{-x}}{2}\\(\sum_{i\ge 0,d\mid i}\frac{x^i}{i!})^k&=n!(\frac{e^x+e^{-x}}{2})^k\\&=\frac{1}{2^k}\sum_{0\le i\le k}\begin{pmatrix}k\\i\end{pmatrix}e^{ix}e^{-x(k-i)} & \text{二项式定理}\\&=\frac{1}{2^k}\sum_{0\le i\le k}\begin{pmatrix}k\\i\end{pmatrix}e^{2ix-kx}\\\text{Ans}&=[x^n]n!(\sum_{i\ge 0,d\mid i}\frac{x^i}{i!})^k\\&=\frac{n!}{2^k}\sum_{0\le i\le k}\begin{pmatrix}k\\i\end{pmatrix}[x^n]e^{2ix-kx}\\&=\frac{n!}{2^k}\sum_{0\le i\le k}\begin{pmatrix}k\\i\end{pmatrix}\frac{(2i-k)^n}{n!} & \text{泰勒展开}\\&=\frac{1}{2^k}\sum_{0\le i\le k}\begin{pmatrix}k\\i\end{pmatrix}(2i-k)^n\end{align*}</script><p>$d=3$：</p><script type="math/tex; mode=display">\begin{align*}\sum_{i\ge 0,d\mid i}\frac{x^i}{i!}&=\frac{1}{d}\sum_{0\le j < d}e^{x\omega_d^j}\\&=\frac{e^x+e^{\omega_3x}+e^{\omega_3^2x}}{3}\\(\sum_{i\ge 0,d\mid i}\frac{x^i}{i!})^k&=n!(\frac{e^x+e^{\omega_3x}+e^{\omega_3^2x}}{3})^k\\&=\frac{1}{3^k}\sum_{0\le i\le k}\begin{pmatrix}k\\i\end{pmatrix}\sum_{0\le j\le k-i}\begin{pmatrix}k-i\\j\end{pmatrix}e^{ix}e^{j\omega_3x}e^{(k-i-j)\omega_3^2x} & \text{多项式定理}\\&=\frac{1}{3^k}\sum_{0\le i\le k}\sum_{0\le j\le k-i}\begin{pmatrix}k\\i\end{pmatrix}\begin{pmatrix}k-i\\j\end{pmatrix}e^{ix+j\omega_3x+k\omega_3^2x-i\omega_3^2x-j\omega_3^2x}\\\text{Ans}&=[x^n]n!(\sum_{i\ge 0,d\mid i}\frac{x^i}{i!})^k\\&=\frac{n!}{3^k}\sum_{0\le i\le k}\sum_{0\le j\le k-i}\begin{pmatrix}k\\i\end{pmatrix}\begin{pmatrix}k-i\\j\end{pmatrix}[x^n]e^{ix+j\omega_3x+k\omega_3^2x-i\omega_3^2x-j\omega_3^2x}\\&=\frac{n!}{3^k}\sum_{0\le i\le k}\sum_{0\le j\le k-i}\begin{pmatrix}k\\i\end{pmatrix}\begin{pmatrix}k-i\\j\end{pmatrix}\frac{(i+j\omega_3+k\omega_3^2-i\omega_3^2-j\omega_3^2)^n}{n!} & \text{泰勒展开}\\&=\frac{1}{3^k}\sum_{0\le i\le k}\sum_{0\le j\le k-i}\begin{pmatrix}k\\i\end{pmatrix}\begin{pmatrix}k-i\\j\end{pmatrix}(i+j\omega_3+k\omega_3^2-i\omega_3^2-j\omega_3^2)^n\end{align*}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;$k$ 种球，每种个数必须是 $d$ 的倍数，共 $n$ 个，求排成一行的方案数.&lt;/p&gt;
&lt;p&gt;$n\le 10^9, k\le 5\times10^5, d\le 3$，答案对 $19491001$ 取模.&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="组合" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"/>
    
    <category term="数论" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"/>
    
    
    <category term="二项式定理" scheme="https://gzezfisher.top/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/"/>
    
    <category term="单位根反演" scheme="https://gzezfisher.top/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
    <category term="泰勒展开" scheme="https://gzezfisher.top/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>LOJ6241 性能优化</title>
    <link href="https://gzezfisher.top/2021/01/15/loj6241/"/>
    <id>https://gzezfisher.top/2021/01/15/loj6241/</id>
    <published>2021-01-15T15:01:00.000Z</published>
    <updated>2022-01-28T02:27:01.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求 </p><script type="math/tex; mode=display">T = \sum_{1\le i\le n}\sum_{1\le j\le\lfloor \frac{n}{i} \rfloor}\sum_{1\le k\le j}[\gcd(j,k)=1]</script><p>多组数据<br><span id="more"></span><br>$n\le 10^{10^6}$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><script type="math/tex; mode=display">T = \sum_{1\le i\le n}\sum_{1\le j\le\lfloor \frac{n}{i} \rfloor}\varphi(j)</script><p>令</p><script type="math/tex; mode=display">\text{S}(n) = \sum_{1\le i\le n}\varphi(i)</script><p>则有</p><script type="math/tex; mode=display">\begin{align*}T &= \sum_{1\le i\le n}\text{S}(\lfloor \frac{n}{i} \rfloor) \\  &= \text{S}(n) + \sum_{2\le i\le n}\text{S}(\lfloor \frac{n}{i} \rfloor) \\\end{align*}</script><p>根据杜教筛，由 $\varphi*\text{I}=\text{Id}$，有</p><script type="math/tex; mode=display">\text{I}(1)\times \text{S}(n)=\sum_{1\le i\le n}\text{Id}(i)-\sum_{2\le i\le n}\text{S}(\lfloor\frac{n}{i}\rfloor)\times \text{I}(i)</script><p>即</p><script type="math/tex; mode=display">\text{S}(n)=\frac{n(n+1)}{2}-\sum_{2\le i\le n}\text{S}(\lfloor\frac{n}{i}\rfloor)</script><p>带回原式得</p><script type="math/tex; mode=display">\begin{align*}T=&\frac{n(n+1)}{2}-\sum_{2\le i\le n}\text{S}(\lfloor\frac{n}{i}\rfloor) + \sum_{2\le i\le n}\text{S}(\lfloor \frac{n}{i} \rfloor)\\=&\frac{n(n+1)}{2}\end{align*}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;求 &lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;T = \sum_{1\le i\le n}\sum_{1\le j\le\lfloor \frac{n}{i} \rfloor}\sum_{1\le k\le j}[\gcd(j,k)=1]&lt;/script&gt;&lt;p&gt;多组数据&lt;br&gt;</summary>
    
    
    
    <category term="题解" scheme="https://gzezfisher.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="https://gzezfisher.top/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"/>
    
    
    <category term="杜教筛" scheme="https://gzezfisher.top/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
  </entry>
  
</feed>
